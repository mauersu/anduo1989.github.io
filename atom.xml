<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[攻城狮笔记]]></title>
  <subtitle><![CDATA[程序猿开荒野史]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-11-08T14:27:18.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[anduo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[常用的shell脚本记录]]></title>
    <link href="http://yoursite.com/2015/11/08/shell-basics/"/>
    <id>http://yoursite.com/2015/11/08/shell-basics/</id>
    <published>2015-11-08T12:20:27.000Z</published>
    <updated>2015-11-08T14:27:18.000Z</updated>
    <content type="html"><![CDATA[<p>主要记录《Linux Shell 脚本攻略》一书很使用的脚本命令，以备用！</p>
<p><img src="http://i12.tietuku.com/eb3991143e5ec10cs.jpg"></p>
<a id="more"></a>
<h2 id="基础入门命令">基础入门命令</h2><p>1、获取字符串长度<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">length</span> = $&#123;<span class="comment">#var&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>2、获得当前使用的SHELL版本<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="variable">$SHELL</span> 或 echo <span class="variable">$0</span></span><br></pre></td></tr></table></figure></p>
<p>3、使用函数添加系统变量<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepend()&#123; [ -d “<span class="variable">$2</span>”] &amp;&amp; eval <span class="variable">$1</span>=\”<span class="variable">$2</span>\$\&#123;<span class="variable">$1</span>:+’:’\$<span class="variable">$1</span>\&#125;\” &amp;&amp; export <span class="variable">$1</span> ;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">prepend</span> PATH /<span class="preprocessor">opt</span>/myapp/<span class="keyword">bin</span><br><span class="line"></span><span class="label">prepend</span> PATH LD_LIBRARY_PATH /<span class="preprocessor">opt</span>/myapp/<span class="keyword">bin</span></span><br></pre></td></tr></table></figure></p>
<p>4、别名的使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> rm=‘cp <span class="variable">$@</span> ~/backup &amp;&amp; rm <span class="variable">$@</span><span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>5、repeat 函数，运行命令直至执行成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">repeat</span></span>()&#123; <span class="keyword">while</span> :; <span class="keyword">do</span> <span class="variable">$@</span> &amp;&amp; <span class="built_in">return</span>; sleep <span class="number">30</span>; <span class="keyword">done</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="命令之乐">命令之乐</h2><h3 id="文件查找与文件列表">文件查找与文件列表</h3><p>1、根据文件名或者正则表达式进行搜索：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find <span class="special">~</span>/ -name “*.txt” -print</span><br><span class="line">find . <span class="command">\(</span> -iname “example*” -o -name “*.pdf” <span class="command">\)</span> -print</span><br><span class="line">find . -iregex “.*<span class="command">\(</span><span class="command">\.</span>py<span class="command">\|</span><span class="command">\.</span>sh<span class="command">\)</span><span class="formula">$”</span></span><br></pre></td></tr></table></figure></p>
<p>2、否定参数<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . ! -name “*.txt” -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></p>
<p>3、基于目录深度的搜索<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -maxdepth <span class="number">1</span> -name “f*” -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></p>
<p>4、根据文件类型搜索<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> <span class="keyword">d</span> -<span class="keyword">print</span></span><br><span class="line">#文件类型: 普通文件-f、符号链接-<span class="keyword">l</span>、目录-<span class="keyword">d</span>、字符设备-c</span><br></pre></td></tr></table></figure></p>
<p>5、根据文件时间进行搜索<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#-atime  访问时间</span></span><br><span class="line"><span class="preprocessor">#-mtime 修改时间</span></span><br><span class="line"><span class="preprocessor">#-ctime  变化时间</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#打印出在最近7天被访问过的所有文件</span></span><br><span class="line">find . -type f -atime -<span class="number">7</span> -print</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#-amin 访问时长</span></span><br><span class="line"><span class="preprocessor">#-mmin 修改时长</span></span><br><span class="line"><span class="preprocessor">#-cmin 变化时长</span></span><br></pre></td></tr></table></figure></p>
<p>6、基于文件大小搜索(k\M\G)<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> +<span class="number">2</span>k</span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> -<span class="number">2</span>k</span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> <span class="number">2</span>k</span><br></pre></td></tr></table></figure></p>
<p>7、删除匹配的文件<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> “*.swap” -delete</span><br></pre></td></tr></table></figure></p>
<h3 id="玩转xargs">玩转xargs</h3><p>1、基础<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> example.txt | xarges -<span class="keyword">n</span> 3</span><br></pre></td></tr></table></figure></p>
<p>2、结合find使用xargs<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> “*.txt” -print0 | xarges -<span class="number">0</span> rm -f</span><br></pre></td></tr></table></figure></p>
<p>3、统计源码目录中所有java程序文件的行数<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> source_code_dir_path -<span class="built_in">type</span> f -<span class="built_in">name</span> “*.java” -print0 | xargs -<span class="number">0</span> wc -l</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要记录《Linux Shell 脚本攻略》一书很使用的脚本命令，以备用！</p>
<p><img src="http://i12.tietuku.com/eb3991143e5ec10cs.jpg" /></p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[awk 日志处理]]></title>
    <link href="http://yoursite.com/2015/11/08/awk-log/"/>
    <id>http://yoursite.com/2015/11/08/awk-log/</id>
    <published>2015-11-08T12:04:27.000Z</published>
    <updated>2015-11-08T14:26:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>这两天自己挽起袖子处理日志，终于把AWK给入门了。其实AWK的基本使用，学起来也就半天的时间，之前总是靠同事代劳，惰性呀。</p>
<p>此文仅为菜鸟入门，运维们请勿围观。</p>
<p><img src="http://i13.tietuku.com/a9888f27c9795139s.jpg"></p>
<p><code>本文转载直网络，如有版权问题，请及时与我联系</code></p>
<a id="more"></a>
<p>下面是被处理的日志的示例，不那么标准，但不标准的日志正是标准的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2015</span>-<span class="number">08</span>-<span class="number">20</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">55.600</span>] - [<span class="number">192.168</span><span class="number">.0</span><span class="number">.73</span>/<span class="number">192.168</span><span class="number">.0</span><span class="number">.75</span>:<span class="number">1080</span> com.vip.xxx.MyService_2<span class="number">.0</span> <span class="number">0</span> <span class="number">106046</span> <span class="number">100346</span> <span class="number">90</span>ms <span class="number">110</span>ms]</span><br></pre></td></tr></table></figure>
<h1 id="基本语句">基本语句</h1><p>最基本的语句，以空格做分割，提取所需的列：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> <span class="label">$0</span>,<span class="label">$1</span>,<span class="label">$2</span>,$(NF-1),<span class="label">$NF</span>,<span class="label">$NF</span>-$(NF-1)&#125;’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure>
<h2 id="1-_输入">1. 输入</h2><p>AWK是针对文件或管道中每行输入的处理语言。所以也可以从管道输入:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep “xxx” access.<span class="keyword">log</span> | awk '&#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’</span><br></pre></td></tr></table></figure></p>
<p>但下面这样写就会成为一个Linux老梗的主角，awk不需要不需要cat的。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> access.<span class="keyword">log</span> | awk '&#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>'</span><br></pre></td></tr></table></figure></p>
<h2 id="2-语句定义">2.语句定义</h2><p>可以快速的用单引号’ ’，把所有语句写成一行。</p>
<p>也可以用-f 指定文件，文件里可以任意换行，增加可读性和重用性。</p>
<p>所有执行语句用{}括起来，{}的外面是一些高级的东西比如过滤条件，见后。</p>
<h2 id="3-_列引用">3. 列引用</h2><p>$0代表整行所有数据，$1代表第一列(终于不是程序员数数从0开始了)。</p>
<p>NF是个代表总列数的系统变量，所以$NF代表最后一列，还支持$(NF-1)来表示倒数第二列。</p>
<p>还支持列之间的运算，如$NF-$(NF-1)是最后两列的值相减。</p>
<p>只写一个print 是 print $0的简写，打印整行所有数据。</p>
<h2 id="4-_输入的列分隔符">4. 输入的列分隔符</h2><p>默认以空格做分割符，也可以重新指定，下例指定了’:’<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'&#123;print <span class="variable">$1</span>,<span class="variable">$2</span>&#125;’ access.log</span></span><br></pre></td></tr></table></figure></p>
<p>也可以正则表达式定义多个分割符，下例指定了 ‘-‘ 和 ‘:’<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> -F <span class="string">'[-:]'</span> <span class="string">'&#123;print <span class="variable">$1</span>,<span class="variable">$2</span>&#125;’ access.log</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-_输出的列间隔">5. 输出的列间隔</h2><p>print $1,$2 中间的’,’逗号，代表打印时第1与第2列之间使用默认分隔符号也就是空格，也可以用” ”来定义其他任意的字符：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> <span class="label">$1</span> <span class="string">"\t"</span> <span class="label">$2</span> <span class="string">" - "</span> <span class="label">$3</span><span class="label">$4xxxxx</span><span class="label">$5&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure>
<p>上例，在第1第2列之间用 tab 分隔，第2第3列之间用” - “分隔，</p>
<p>也可以什么都不写代表中间没分隔，比如第3第4列之间，或者乱写一些字符没用” “括起来，也等于没写，比如第4第5列之间。</p>
<p>数字类型，字符串类型</p>
<p>虽然上例最后两列的值是字符串类型的，带着ms字样，看起来不能做算术运算。</p>
<p>但其实两个列相减时，AWK就会神奇地把它们转换为纯数字。同样，做累计的时候，sum=sum+$NF，也能自动转换为数字。</p>
<p>如果想对某个字符列比较是否大于阀值，先把它转回数字就行了</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sed</span> <span class="string">"s|ms]||g"</span> access.log | awk <span class="string">' <span class="variable">$NF</span>&gt;100 &#123;print&#125;'</span></span><br></pre></td></tr></table></figure>
<p>其实可以简写成下面的样子，性能还比使用sed略快：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk ' <span class="label">$NF</span>*1&gt;100 &#123;<span class="keyword">print</span>&#125;’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk ' int(<span class="label">$NF</span>)&gt;100 &#123;<span class="keyword">print</span>&#125;’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<h1 id="BEGIN与END语句">BEGIN与END语句</h1><p>BEGIN与END后的语句定义在处理全部文本内容之前与之后的语句。</p>
<h2 id="1-计算累计值和平均值">1.计算累计值和平均值</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">sum</span>+=<span class="label">$NF&#125;</span> END &#123;<span class="keyword">print</span> <span class="keyword">sum</span>, <span class="keyword">sum</span>/NR&#125;'</span><br></pre></td></tr></table></figure>
<p>上例对每行输入内容进行最后一列的值的累计，而END后的语句，打印累计结果 和平均值，NR是系统变量代表总行数。</p>
<h2 id="2-打印表头">2.打印表头</h2><p>还可以定义BEGIN语句打印表头，定义变量什么的。<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN&#123;<span class="literal">print</span> <span class="string">"Date\t\tTime\t\tCost”&#125; &#123;print <span class="variable">$1</span> "</span>\t<span class="string">"<span class="variable">$2</span> "</span>\t<span class="string">" <span class="variable">$NF</span>&#125;’ access.log</span></span><br></pre></td></tr></table></figure></p>
<p>上例表头用两个制表符分隔，内容则用一个制表符分隔，有良好的对齐效果。</p>
<h1 id="过滤行">过滤行</h1><h2 id="1-_简单字符匹配">1. 简单字符匹配</h2><p>先用grep过滤也是可以的，也可以用awk简单在执行语句之外的/ /之间定义正则表达式<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/192.168.0.4[1-5]/ &#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "192.168.0.4[1-5]” access.<span class="keyword">log</span>｜ awk ‘&#123;<span class="keyword">print</span> <span class="label">$1&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-_针对某一列的字符匹配">2. 针对某一列的字符匹配</h2><p>针对第4列的地址段匹配，~ 是字符匹配，!~则是不匹配的意思。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> <span class="string">'<span class="variable">$4</span> ~ /192.168.0.4[1-5]/ &#123;print&#125;'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-_针对数值的过滤">3. 针对数值的过滤</h2><p>支持==, !=， , &gt;, =, &gt;=<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> <span class="string">'$(NF-1)*1==100 &#123;print&#125;'</span></span><br><span class="line">awk <span class="string">'<span class="variable">$NF</span>-$(NF－1)&gt;100 &#123;print&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>见前，对于非纯数字的字段，可以用算术运算让它转回数字。</p>
<h2 id="4-_多条件同时存在">4. 多条件同时存在</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> <span class="string">'(<span class="variable">$12</span> &gt;150 || $(13)&gt;250) &#123;print&#125;'</span></span><br></pre></td></tr></table></figure>
<h2 id="5-_使用if语句">5. 使用if语句</h2><p>如果逻辑更复杂，可以考虑使用if,else等语句<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123; <span class="flow">if</span> ($(NF-<span class="number">1</span>)*<span class="number">1</span>&gt;<span class="number">100</span>) <span class="built_in">print</span>&#125;'</span><br></pre></td></tr></table></figure></p>
<h1 id="其他">其他</h1><h2 id="1-外部传入参数">1.外部传入参数</h2><p>比如从外面传入超时的阀值，注意threshold在命令行中的位置。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">if</span>($(NF)*1&gt;threshold) <span class="keyword">print</span>&#125;' threshold=20 access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-常用函数">2.常用函数</h2><p>最有用是gsub和sub，match，index等。其中gsub将一个字符串替换为目标字符串，可选定整行替换或只替换某一列。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;gsub(<span class="string">"ms]"</span>,<span class="string">""</span>,<span class="label">$NF</span>); <span class="keyword">if</span>( <span class="label">$NF</span>&gt;100 ) <span class="keyword">print</span>&#125;' access.<span class="literal">log</span></span><br></pre></td></tr></table></figure>
<h1 id="一些例子">一些例子</h1><h2 id="1-截取日期段内段数据">1.截取日期段内段数据</h2><p>方式有很多，都是随着日志格式不同自由发挥。</p>
<p>比如下段截取17:30:30 秒到 17.31:00的数据，先抽取出时分秒三列，再拼成一个数字进行比较<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> -F <span class="string">"[ :.]"</span> <span class="string">'<span class="variable">$2</span><span class="variable">$3</span><span class="variable">$4</span>&gt;=173030 <span class="variable">$2</span><span class="variable">$3</span><span class="variable">$4173100</span> &#123;print&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>也可以匹配某个整点时间， 下例取11点的日志:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/[2015-08-20 11:/ &#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<p>取11点01分到05分的数据:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/[2015-08-20 11:0[1-5]:/ &#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<h1 id="2-_找出超时的数据集中发生的时间">2. 找出超时的数据集中发生的时间</h1><p>第一段找出超时记录，第二段过滤掉时间戳里的微秒，然后按秒来合并，并统计该秒超时的次数。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'$(NF)*1&gt;100 &#123;print&#125;’ access.log | awk -F"." '</span>&#123;print <span class="variable">$1</span>&#125;<span class="string">' | sort | uniq -c</span></span><br></pre></td></tr></table></figure></p>
<p>————- END ——————–</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>这两天自己挽起袖子处理日志，终于把AWK给入门了。其实AWK的基本使用，学起来也就半天的时间，之前总是靠同事代劳，惰性呀。</p>
<p>此文仅为菜鸟入门，运维们请勿围观。</p>
<p><img src="http://i13.tietuku.com/a9888f27c9795139s.jpg" /></p>
<p><code>本文转载直网络，如有版权问题，请及时与我联系</code></p>]]>
    
    </summary>
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac中基于Homebrew搭建python开发环境]]></title>
    <link href="http://yoursite.com/2015/11/08/python-mac-start-env/"/>
    <id>http://yoursite.com/2015/11/08/python-mac-start-env/</id>
    <published>2015-11-08T12:04:27.000Z</published>
    <updated>2015-11-29T12:07:41.000Z</updated>
    <content type="html"><![CDATA[<p>@(python)[mac|homebrew|shell|开发环境]</p>
<p><img src="http://i5.tietuku.com/25c8e2c52434a7e7.png" alt="python"></p>
<p>转移到mac上了。这里是在lion中搭建python开发环境的简单记录。这份记录不是一份step by step.而是事后写的记录，可能有记忆遗漏。如果有错误，请指正。</p>
<a id="more"></a>
<h3 id="1-安装homebrew的准备">1.安装homebrew的准备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R `whoami` /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>homebrew希望在没有sudo的环境下工作（Homebrew is designed to work without using sudo.）所以首先对/usr/local/这个文件夹赋权限。（homebrew的软件是安装在这里的）</p>
</blockquote>
<h3 id="2-通过shell安装">2.通过shell安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://gist.github.com/raw/323731/install_homebrew.rb)</span>"</span></span><br></pre></td></tr></table></figure>
<p>3.配置环境变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<p>加入以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Setting PATH for Homebrew</span></span><br><span class="line">PATH=<span class="string">"/usr/local/bin:<span class="variable">$&#123;PATH&#125;</span>"</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure></p>
<p>Ok，这样homebrew就装好了。</p>
<h3 id="4-brew的简单命令">4.brew的简单命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ brew search &lt;pkg_name&gt;  <span class="comment">#查找软件包</span></span><br><span class="line">$ brew install &lt;pkg_name&gt;  <span class="comment">#安装软件包</span></span><br><span class="line">$ brew list <span class="comment">#列出软件包</span></span><br><span class="line">$ brew uninstall &lt;pkg_name&gt; <span class="comment">#卸载软件包</span></span><br><span class="line">$ brew update <span class="comment">#更新</span></span><br><span class="line">$ brew info &lt;pkg_name&gt; <span class="comment">#查看软件包的基本资料</span></span><br></pre></td></tr></table></figure>
<h3 id="5-安装python">5.安装python</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install python --framework --universal</span><br><span class="line">The –framework option tells it to build as a Framework, <span class="built_in">which</span> has some downstream niceties, and –universal builds a universal (<span class="number">32</span>/<span class="number">64</span> bit) version.</span><br></pre></td></tr></table></figure>
<h3 id="6-将python加入path">6.将python加入path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~/.bash_profile</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/share/python:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<h3 id="7-检查安装是否正确">7.检查安装是否正确</h3><p>此时，最好重启term。如果要确认修改是否正确，可以用which python和which easy_install查看python的路径是否正确。如果返回为</p>
<p>/usr/local/bin/python<br>和</p>
<p>/usr/local/share/python/easy_install<br>那么，安装正确</p>
<h3 id="8-通过easy_install安装pip">8.通过easy_install安装pip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ easy_install pip</span><br></pre></td></tr></table></figure>
<h3 id="9-安装virtualenv_和_virtuanenvwarpper">9.安装virtualenv 和 virtuanenvwarpper</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/share/python/pip install virtualenv</span><br><span class="line">$ /usr/<span class="built_in">local</span>/share/python/pip install virtualenvwrapper <span class="comment">##其实这个装不装已经无所谓了。</span></span><br></pre></td></tr></table></figure>
<h3 id="10-建立和项目相关的env">10.建立和项目相关的env</h3><p>比如，项目文件在~/projects中,那么，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/projects</span><br><span class="line">$ virtualenv --no-site-packages project_name</span><br><span class="line">The --no-site-packages flag is deprecated; it is now the default behavior.</span><br><span class="line">New python executable <span class="keyword">in</span> project_name/bin/python</span><br><span class="line">Installing setuptools............done.</span><br><span class="line">Installing pip...............done.</span><br></pre></td></tr></table></figure></p>
<h3 id="11-启动虚拟环境">11.启动虚拟环境</h3><p>首先进入刚刚建立的虚拟环境目录，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project_name</span><br><span class="line">$ <span class="built_in">source</span> bin/activate</span><br></pre></td></tr></table></figure></p>
<p>注意，此时shell提示符前多了虚拟环境的名称提示：<br>(project_name)….$<br>Now,do anything you want.</p>
<h3 id="12-退出虚拟环境">12.退出虚拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure>
<h3 id="13-pip的设定">13.pip的设定</h3><p>如果要保证在虚拟环境中调用系统的pip,可以在~/.bash_profile里加上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PIP_REQUIRE_VIRTUALENV=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>如果要让系统的pip自动调用虚拟环境中的pip<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PIP_RESPECT_VIRTUALENV=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="14-安装你需要的软件包（注意提示符）">14.安装你需要的软件包（注意提示符）</h3><p>(project_name)….$ pip install pkg_name<br>【END】</p>
<hr>
<p>ttp://matrix.windhunter.net/blog/2012/01/setup-python-env-on-lion-471.html</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>@(python)[mac|homebrew|shell|开发环境]</p>
<p><img src="http://i5.tietuku.com/25c8e2c52434a7e7.png" alt="python"></p>
<p>转移到mac上了。这里是在lion中搭建python开发环境的简单记录。这份记录不是一份step by step.而是事后写的记录，可能有记忆遗漏。如果有错误，请指正。</p>]]>
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="开发环境" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的算法图书]]></title>
    <link href="http://yoursite.com/2015/11/08/my-ago-books/"/>
    <id>http://yoursite.com/2015/11/08/my-ago-books/</id>
    <published>2015-11-08T12:04:27.000Z</published>
    <updated>2015-11-29T12:08:08.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://i5.tietuku.com/4219fa129528d909.jpg" alt="算法"></p>
<p>@(读书)[算法|内功|经典]</p>
<a id="more"></a>
<blockquote>
<p>算法荐书（程序员练功+大众科普）</p>
</blockquote>
<h3 id="入门第一书，你一定能看懂">入门第一书，你一定能看懂</h3><p><img src="http://i12.tietuku.com/fbdbeb745327d8c6.png" alt="啊哈!算法"></p>
<p>没有枯燥的描述，没有难懂的公式，一切以实际应用为出发点，通过幽默的语言配以可爱的插图来讲解算法。你更像是在阅读一个个轻松的小故事或是在玩一把趣味解谜 游戏，在轻松愉悦中便掌握算法精髓，感受算法之美。</p>
<p>本书中涉及的数据结构有栈、队列、链表、树、并查集、堆和图等；涉及的算法有排序、枚举、 深度和广度优先搜索、图的遍历，当然还有图论中不可以缺少的四种最短路径算法、两种最小生成树算法、 割点与割边算法、二分图的最大匹配算法等。</p>
<p><strong><em>豆瓣8.1分</em></strong></p>
<p>“插图和讲解相当到位~~让人看了很感兴趣，把算法用非常形象的方式表达出来，通俗易懂，这下学习算法的朋友有福了。 ”</p>
<h3 id="入门+进阶，经典名著">入门+进阶，经典名著</h3><p><img src="http://i12.tietuku.com/13eb42398d5ccc47.png" alt="算法"></p>
<ul>
<li>Sedgewick之巨著，与高德纳TAOCP一脉相承</li>
<li>几十年多次修订，经久不衰的畅销书</li>
<li>涵盖所有程序员必须掌握的50种算法</li>
</ul>
<p>本书作为算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。第4版具体给出了每位程序员应知应会的50个算法，提供了实际代码，而且这些Java代码实现采用了模块化的编程风格，读者可以方便地加以改造。本书配套网站提供了书中内容的摘要及更多的代码实现、测试数据、练习、教学课件等资源。</p>
<p><strong><em>豆瓣9.3分</em></strong></p>
<p>“这本书也非常牛，用Java实现，我觉得这本书是最适合用来算法入门的，说它适合入门不是说它太浅，而是讲的深入浅出，非常容易理解，里面那些小彩图呀，啧啧，美极了！”</p>
<h3 id="进阶首选，与实际生活最贴近的趣味算法书">进阶首选，与实际生活最贴近的趣味算法书</h3><p>![算法的乐趣]<a href="http://i12.tietuku.com/ab4204adf230e82b.png" target="_blank" rel="external">http://i12.tietuku.com/ab4204adf230e82b.png</a>)</p>
<p>算法之大，大到可以囊括宇宙万物的运行规律；算法之小，小到寥寥数行代码即可展现一个神奇的功能。算法的应用和乐趣在生活中无处不在：</p>
<ul>
<li>历法和二十四节气计算使用的是霍纳法则和求解一元高次方程的牛顿迭代法；</li>
<li>音频播放器跳动的实时频谱背后是离散傅立叶变换算法；</li>
<li>DOS时代著名的PCX图像文件格式使用的是简单有效的RLE压缩算法；</li>
<li>RSA加密算法的光环之下是朴实的欧几里得算法、蒙哥马利算法和米勒-拉宾算法；</li>
<li>井字棋、黑白棋、五子棋和俄罗斯方块游戏背后是各种有趣的AI算法；</li>
<li>华容道游戏求解的简单穷举算法中还蕴藏着对棋盘状态的哈希算法；</li>
<li>遗传算法神秘不可测，但用遗传算法求解0-1背包问题只用了60多行代码……</li>
</ul>
<p>一本书带你走进色彩缤纷的算法世界，让你尽享算法的乐趣。</p>
<p><code>新上市</code></p>
<p>这本书和常见的算法书不一样，比我想象的有意思：<br>“全书只在前三章系统介绍了各种算法的逻辑结构，其后章节都是针对具体问题构造算法，一直以为动态规划是多么高大上的方法，经作者的介绍和例子，好像明白了一些。 当初毕业设计做的就是一个俄罗斯方块游戏，但是只能自己玩，没有电脑AI，看了本书才知道俄罗斯方块有那么多有名的算法。”</p>
<h3 id="ACM必读">ACM必读</h3><p><img src="http://i12.tietuku.com/cfee5c52f6373b0a.png" alt="算法问题实战策略"></p>
<ul>
<li>ACM入门详解</li>
<li>顶级高手力作</li>
<li>韩国最棒的算法实战书</li>
</ul>
<p>本书通过解答编程竞赛中的问题使读者能够学习到各种算法的设计技巧和算法结构，进而能够提高读者的问题解决能力。</p>
<p><code>新上市</code></p>
<p>本书在第一章就开门见山地给出了程序设计的目的和意义。通过列举示例使未接触过程序设计竞赛的读者对程序设计有了直观和易懂的了解。作者还列举了程序设计竞赛的题目具有的优势，层次分明，条理性强，简单而不失深度地向读者介绍了通过程序设计竞赛能够获益良多。同时，作者也给出了阅读本书的建议和方法，这样能使读者阅读本书时更有效率。</p>
<p>和大多数介绍算法的书不同，本书还为读者介绍了值得参加的程序设计竞赛，这一点对有兴趣参加竞赛的读者很有帮助。 本书第二章并不像有些介绍算法的书一样开始直接进入算法讲解，而是向读者详细阐述了如何解决问题，通过对解决问题的过程和解决问题的策略两部分内容进行详细介绍，使读者更能理解算法问题的本质是什么，算法问题的解决思路是什么。这些对于学习算法的读者而言是非常重要的，需要从开始就想明白。本书在这方面介绍的非常好，对想要了解和学习算法的读者来说，是一本获益匪浅的好书。</p>
<p><img src="http://i12.tietuku.com/fb17b8791d07e27a.png" alt="挑战程序设计竞赛"></p>
<ul>
<li>世界顶级程序设计高手的经验总结</li>
<li>【ACM-ICPC全球总冠军】巫泽俊主译</li>
<li>日本ACM-ICPC参赛者人手一册</li>
</ul>
<p>本书对程序设计竞赛中的基础算法和经典问题进行了汇总，分为准备篇、初级篇、中级篇与高级篇4章。作者结合自己丰富的参赛经验，对严格筛选的110 多道各类试题进行了由浅入深、由易及难的细致讲解，并介绍了许多实用技巧。每章后附有习题，供读者练习，巩固所学。</p>
<p><code>豆瓣9.0分</code></p>
<blockquote>
<p>“通过这本书，算法竞赛题我入门了。”</p>
</blockquote>
<h3 id="通识类3本，各领风骚">通识类3本，各领风骚</h3><p><img src="http://i12.tietuku.com/8a1132d6715942fa.png" alt="算法帝国"></p>
<p>今天，算法涉足的领域已经远远超出了其创造者的预期。特别是进入信息时代以后，算法的应用涵盖金融、医疗、法律、体育、娱乐、外交、文化、国家安全等诸多方面，显现出源于人类而又超乎人类的强大威力。本书是《纽约时报》畅销书作者的又一力作，通过一个又一个引人入胜的故事，向读者介绍了算法掌控世界的真实情况，揭示了“机器人革命”是如何悄悄地在我们身边发生的。</p>
<p><code>豆瓣7.3分</code></p>
<blockquote>
<p>“数学和算法之所以令人爱不释手，在于它们改变世界的无限潜能，可惜多数人看不到这一面。”</p>
</blockquote>
<p><img src="http://i12.tietuku.com/0f84b66c91e226e8.png" alt="迷茫的旅行商"><br>假设一名旅行商打算拜访一张城市列表中的所有城市，每座城市只去一次，最后回到出发地。要怎么走才能让路线最短呢？这就是旅行商问题，乍一听很简单，在应用数学界却是一道研究极其热烈的难题，时至今日仍无人能解。本书中，William J. Cook将带领读者踏上一场数学之旅，跟随旅行商的脚步，从19世纪初爱尔兰数学家W. R. Hamilton最初定义该问题开始，一路奔向当今最前沿、最顶尖的解题尝试。</p>
<p><code>豆瓣8.1分</code></p>
<blockquote>
<p>“关于经典的TSP问题的一切……TSP问题看似简单，特别是在问题规模较小时，最优解似乎是不言自明的，但当问题规模不断扩大，即使是人脑这样的“超大规模并行”的wetware也会立刻感到无所适从、进而“迷茫”。 那最终使我们走出黑暗的、不服输的智慧火花又一次在热烈的燃烧中接力，于是有了最近邻算法、有了贪心算法、有了插入算法、有了Christofides算法、有了LKH算法、有了线性规划算法。”</p>
</blockquote>
<p><img src="http://i12.tietuku.com/08b6467b1cd5e0d5.png" alt="可能与不可能的边界"></p>
<ul>
<li>Vint Cerf等众多世界级计算机科学家联袂推荐</li>
<li>《出版人周刊》《科学》等杂志好评如潮</li>
<li>像《时间简史》一样风趣幽默的P/NP问题阐释</li>
<li>关于计算、数学与逻辑的一场盛宴</li>
</ul>
<p><code>豆瓣7.4分</code></p>
<blockquote>
<p>“本书涉及了P/NP问题的方方面面，对于这样一本薄薄的册子自然无法太过深入，但是相信读者读过对此问题会有一个宏观的认识。作者已经做得很好。这本书就是一张入场券，带领读者进入这个奇妙的世界。”</p>
</blockquote>
<h3 id="当然，说到算法书，还有一本不得不推荐的">当然，说到算法书，还有一本不得不推荐的　</h3><p><img src="http://i12.tietuku.com/19ad2a82e31bba8b.png" alt="算法导论"><br><code>豆瓣9.1分</code></p>
<p>经典、权威、全面、严谨，唯一的问题是理解起来有点儿难度。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://i5.tietuku.com/4219fa129528d909.jpg" alt="算法"></p>
<p>@(读书)[算法|内功|经典]</p>]]>
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="book" scheme="http://yoursite.com/categories/book/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[R语言实现之决策树]]></title>
    <link href="http://yoursite.com/2015/11/08/r-ctree/"/>
    <id>http://yoursite.com/2015/11/08/r-ctree/</id>
    <published>2015-11-07T19:07:43.000Z</published>
    <updated>2015-11-08T14:37:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="决策树">决策树</h1><p>决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。</p>
<p>这一节学习使用包<code>party</code>里面的函数ctree()为数据集iris建立一个<code>决策树</code>。属性<code>Sepal.Length</code>（萼片长度）、<code>Sepal.Width</code>（萼片宽度）、<code>Petal.Length</code>（花瓣长度）以及<code>Petal.Width</code>（花瓣宽度）被用来预测鸢尾花的<code>Species</code>（种类）。在这个包里面，函数ctree()建立了一个决策树，predict()预测另外一个数据集。</p>
<p>在建立模型之前，iris（鸢尾花）数据集被分为两个子集：训练集（70%）和测试集（30%）。使用随机种子设置固定的随机数，可以使得随机选取的数据是可重复利用的。</p>
<a id="more"></a>
<h2 id="导入构建决策树所需要的库">导入构建决策树所需要的库</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;<span class="keyword">library</span>(<span class="string">"party"</span>)<span class="comment">#导入数据包</span></span><br></pre></td></tr></table></figure>
<h2 id="查看本次构建决策树所用的数据源">查看本次构建决策树所用的数据源</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="title">str</span><span class="params">(iris)</span></span>#集中展示数据文件的结构</span><br><span class="line"><span class="string">'data.frame'</span>: <span class="number">150</span> obs. of <span class="number">5</span> variables: <span class="number">150</span>条观测值，<span class="number">5</span>个变量</span><br><span class="line">$ Sepal<span class="class">.Length</span>: num <span class="number">5.1</span> <span class="number">4.9</span> <span class="number">4.7</span> <span class="number">4.6</span> <span class="number">5</span> <span class="number">5.4</span> <span class="number">4.6</span> <span class="number">5</span> <span class="number">4.4</span> <span class="number">4.9</span> ...</span><br><span class="line">$ Sepal<span class="class">.Width</span> : num <span class="number">3.5</span> <span class="number">3</span> <span class="number">3.2</span> <span class="number">3.1</span> <span class="number">3.6</span> <span class="number">3.9</span> <span class="number">3.4</span> <span class="number">3.4</span> <span class="number">2.9</span> <span class="number">3.1</span> ...</span><br><span class="line">$ Petal<span class="class">.Length</span>: num <span class="number">1.4</span> <span class="number">1.4</span> <span class="number">1.3</span> <span class="number">1.5</span> <span class="number">1.4</span> <span class="number">1.7</span> <span class="number">1.4</span> <span class="number">1.5</span> <span class="number">1.4</span> <span class="number">1.5</span> ...</span><br><span class="line">$ Petal<span class="class">.Width</span> : num <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.4</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.1</span> ...</span><br><span class="line">$ Species : Factor w/ <span class="number">3</span> levels <span class="string">"setosa"</span>,<span class="string">"versicolor"</span>,..: <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> ...</span><br><span class="line"> </span><br><span class="line">Call function ctree to build <span class="tag">a</span> decision tree. The first parameter is <span class="tag">a</span> formula, which defines <span class="tag">a</span> target variable and <span class="tag">a</span> list of independent variables.</span><br></pre></td></tr></table></figure>
<h2 id="函数构建决策树">函数构建决策树</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;iris_ctree&lt;-ctree(<span class="type">Species</span> ~ <span class="type">Sepal</span>.<span class="type">Length</span> + <span class="type">Sepal</span>.<span class="type">Width</span> + <span class="type">Petal</span>.<span class="type">Length</span> + <span class="type">Petal</span>.<span class="type">Width</span>, <span class="typedef"><span class="keyword">data</span>=iris)</span></span><br></pre></td></tr></table></figure>
<h2 id="查看决策树的具体信息">查看决策树的具体信息</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="title">print</span><span class="params">(iris_ctree)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="决策树案例拟合图">决策树案例拟合图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Conditional inference tree with <span class="number">4</span> terminal nodes</span><br><span class="line"></span><br><span class="line">Response:  Species </span><br><span class="line">Inputs:  Sepal.Length, Sepal.Width, Petal.Length, Petal.Width </span><br><span class="line">Number of observations:  <span class="number">150</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) Petal.Length &lt;= <span class="number">1.9</span>; criterion = <span class="number">1</span>, statistic = <span class="number">140.264</span></span><br><span class="line">  <span class="number">2</span>)*  weights = <span class="number">50</span> </span><br><span class="line"><span class="number">1</span>) Petal.Length &gt; <span class="number">1.9</span></span><br><span class="line">  <span class="number">3</span>) Petal.Width &lt;= <span class="number">1.7</span>; criterion = <span class="number">1</span>, statistic = <span class="number">67.894</span></span><br><span class="line">    <span class="number">4</span>) Petal.Length &lt;= <span class="number">4.8</span>; criterion = <span class="number">0.999</span>, statistic = <span class="number">13.865</span></span><br><span class="line">      <span class="number">5</span>)*  weights = <span class="number">46</span> </span><br><span class="line">    <span class="number">4</span>) Petal.Length &gt; <span class="number">4.8</span></span><br><span class="line">      <span class="number">6</span>)*  weights = <span class="number">8</span> </span><br><span class="line">  <span class="number">3</span>) Petal.Width &gt; <span class="number">1.7</span></span><br><span class="line">    <span class="number">7</span>)*  weights = <span class="number">46</span></span><br></pre></td></tr></table></figure>
<h2 id="绘制构建完的决策树图">绘制构建完的决策树图</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="title">plot</span><span class="params">(iris_ctree)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="未剪枝的决策树图">未剪枝的决策树图</h2><p><img src="http://i12.tietuku.com/f59a8fd34a6eb6eas.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对该决策树进行适当的剪枝，防止过拟合，使得树能够较好地反映数据内在的规律并在实际应用中有意义</span></span><br><span class="line">&gt;plot(iris_ctree, <span class="built_in">type</span>=<span class="string">"simple"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="决策树案例拟合图-1">决策树案例拟合图</h2><p><img src="http://i12.tietuku.com/7665e4093ba82183s.png"></p>
<p>在图1中，每一个叶子的节点的条形图都显示了观测值落入三个品种的概率。在图2中，这些概率以每个叶子结点中的y值表示。例如：结点2里面的标签是“n=50 y=(1,0,0)”，指的是这一类中一共有50个观测值，并且所有的观测值的类别都属于第一类setosa（山鸢尾）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="决策树">决策树</h1><p>决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。</p>
<p>这一节学习使用包<code>party</code>里面的函数ctree()为数据集iris建立一个<code>决策树</code>。属性<code>Sepal.Length</code>（萼片长度）、<code>Sepal.Width</code>（萼片宽度）、<code>Petal.Length</code>（花瓣长度）以及<code>Petal.Width</code>（花瓣宽度）被用来预测鸢尾花的<code>Species</code>（种类）。在这个包里面，函数ctree()建立了一个决策树，predict()预测另外一个数据集。</p>
<p>在建立模型之前，iris（鸢尾花）数据集被分为两个子集：训练集（70%）和测试集（30%）。使用随机种子设置固定的随机数，可以使得随机选取的数据是可重复利用的。</p>]]>
    
    </summary>
    
      <category term="r" scheme="http://yoursite.com/tags/r/"/>
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[R语言基础知识]]></title>
    <link href="http://yoursite.com/2015/11/08/r-basics/"/>
    <id>http://yoursite.com/2015/11/08/r-basics/</id>
    <published>2015-11-07T17:25:14.000Z</published>
    <updated>2015-11-08T14:42:54.000Z</updated>
    <content type="html"><![CDATA[<p>R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。</p>
<p>R语言是在大数据时代被工业界了解和认识的语言，R语言被时代赋予了，挖掘数据价值，发现数据规律，创造数据财富的任务。</p>
<p>R语言也是帮助人们发挥智慧和创造力的最好的生产工具，我们不仅要学好R语言，还要用好R语言，为社会注入更多的创新的生产力。</p>
<p><img src="http://www.idatacamp.com/wordpress/wp-content/uploads/2015/09/14210N40130-194U.jpg" width="67.5%"></p>
<p>我认为“R是最值得学习的编程语言”。不论你还在读书，还是已经工作，掌握R语言这个工具，找最适合自己的位置，前途将无限量。</p>
<p>本文主要记录了笔者自学R的基础知识点，这里直介绍R的基础入门知识，全文使用RStudio操作</p>
<a id="more"></a>
<h2 id="目录">目录</h2><ul>
<li>显示内容</li>
<li>设置变量</li>
<li>生成向量</li>
<li>基本统计量的计算</li>
<li>数列生成</li>
<li>向量比较、操作</li>
<li>函数定义</li>
</ul>
<h2 id="显示内容">显示内容</h2><h3 id="问题">问题</h3><p>如何通过R软件显示某一变量或表达式的值。</p>
<h3 id="解决方案">解决方案</h3><p>在提示符后直接输入变量名或表达式，R软件便会直接在屏幕中输出其值。使用print函数能输出所有的变量和表达式值，使用cat函数则能选择以用户自定义的格式显示对象的值。</p>
<h3 id="讨论">讨论</h3><p>通过R软件显示结果的步骤很简单：只需在提示符后输入变量名或表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; pi</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.141593</span></span><br><span class="line">&gt; <span class="built_in">sqrt</span>(<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.414214</span></span><br></pre></td></tr></table></figure>
<p>当输入如上表达式后，R软件会对表达式进行计算并自动调用print函数显示结果。因此上述命令等同于如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(pi)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.141593</span></span><br><span class="line">&gt; print(<span class="built_in">sqrt</span>(<span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.414214</span></span><br></pre></td></tr></table></figure>
<p>print函数的优点在于它知道该以何种格式显示结果，包括一些具有格式的变量，如矩阵和列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span></span><br><span class="line">&gt; print(<span class="built_in">list</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>))</span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"a"</span></span><br><span class="line">[[<span class="number">2</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"b"</span></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"c"</span></span><br></pre></td></tr></table></figure>
<p>这一命令很常用，因为你可以随时通过print函数显示数据，而不必在意数据显示的顺序与逻辑，即使对如矩阵这样复杂的数据格式也是如此。</p>
<p>但print函数也有其局限性：print函数每次只能显示一个对象。同时显示多个变量会得到如下结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">print</span><span class="params">(<span class="string">"The zero occurs at"</span>, <span class="number">2</span>*pi, <span class="string">"radians."</span>)</span></span></span><br><span class="line">Error <span class="keyword">in</span> print.<span class="function"><span class="title">default</span><span class="params">(<span class="string">"The zero occurs at"</span>, <span class="number">2</span> * pi, <span class="string">"radians."</span>)</span></span> :  unimplemented type <span class="string">'character'</span> <span class="keyword">in</span> <span class="string">'asLogical'</span></span><br></pre></td></tr></table></figure>
<p>只有通过多次使用print函数才能显示多个对象，但用户往往会认为这种方法过于繁琐：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(<span class="string">"The zero occurs at"</span>); print(<span class="number">2</span>*pi); print(<span class="string">"radians"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"The zero occurs at"</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">6.283185</span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"radians"</span></span><br></pre></td></tr></table></figure>
<p>cat函数是另外一种可以替代print的显示方式。它可以将多个对象连接并以连续的方式显示：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat(<span class="string">"The zero occurs at"</span>, <span class="number">2</span>*<span class="constant">pi</span>, <span class="string">"radians."</span>, <span class="string">"\n"</span>)</span><br><span class="line">The <span class="constant">zero</span> occurs <span class="keyword">at</span> <span class="number">6.283185</span> radians.</span><br></pre></td></tr></table></figure>
<p><code>注意</code>，cat函数默认在两个对象间加上空格。如果需要换行，则可以使用换行符（\n）来结束本行语句。</p>
<p>cat函数也能显示简单向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; cat(<span class="string">"The first few Fibonacci numbers are:"</span>, fib, <span class="string">"...\n"</span>)</span><br><span class="line">The first few Fibonacci numbers are: <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> ...</span><br></pre></td></tr></table></figure>
<p>cat函数对变量的输出有更多的控制和选择，这在R程序中尤为重要。但它也有缺陷，即cat函数无法显示复合的数据结构，如矩阵和列表。用cat函数显示列表会得到以下结果：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">cat</span>(<span class="keyword">list</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>))</span><br><span class="line"><span class="keyword">Error</span> <span class="keyword">in</span> <span class="keyword">cat</span>(<span class="keyword">list</span>(...), <span class="keyword">file</span>, sep, fill, labels, <span class="keyword">append</span>) :</span><br><span class="line">argument 1 (<span class="keyword">type</span> <span class="keyword">list</span>) cannot be handled <span class="keyword">by</span> <span class="keyword">cat</span></span><br></pre></td></tr></table></figure>
<h2 id="设定变量">设定变量</h2><h3 id="问题-1">问题</h3><p>如何将某个值赋值给一个变量。</p>
<h3 id="解决方案-1">解决方案</h3><p>使用赋值运算符（&lt;-）进行赋值。在赋值前无须对变量进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="讨论-1">讨论</h2><p>R软件采用“计算器”模式，方便快捷。但是，有时候需要定义变量并保存变量值。这省去了重复输入的时间并使你的工作更为明晰。</p>
<p>在R软件中，不必对变量进行声明或者显式地创建变量，只需要将值赋予一个名称，R软件就会自动生成该名称的变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">3</span></span><br><span class="line">&gt; y &lt;- <span class="number">4</span></span><br><span class="line">&gt; z &lt;- <span class="built_in">sqrt</span>(x^<span class="number">2</span> + y^<span class="number">2</span>)</span><br><span class="line">&gt; print(z)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，赋值操作由一个小于号（&lt;）和连字符（-）构成，两个符号之间没有空格。</p>
<p>当使用此种方法定义变量时，该变量将存储到当前的工作空间中。此时工作空间仅存储在计算机的内存中，当退出R软件时可保存至本地硬盘。工作空间会永久保存该变量，直至用户删除或替代该变量。</p>
<p>R软件是动态的输入语言，即可随意改变变量的数据类型。我们可以先定义x为数值型变量，随后马上对其赋值一个字符串向量，在这一过程中R软件能完全理解用户的意图：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  x &lt;- <span class="number">3</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span><span class="params">(x)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; x &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="string">"fee"</span>, <span class="string">"fie"</span>, <span class="string">"foe"</span>, <span class="string">"fum"</span>)</span></span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span><span class="params">(x)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"fee"</span> <span class="string">"fie"</span> <span class="string">"foe"</span> <span class="string">"fum"</span></span><br></pre></td></tr></table></figure>
<p>在某些R函数中，你会看到很特别的赋值符号&lt;&lt;-：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这一操作能强制赋值给一个全局变量，而不是局部变量。</p>
<p>为了全面介绍，在此给出另外两种赋值形式。也可以在命令提示符中使用单个等号（=）对变量进行赋值。在所有可以应用向左赋值符号（&lt;-）的地方都可以使用向右赋值符号（-&gt;），它对右侧变量进行赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; foo = <span class="number">3</span></span><br><span class="line">&gt; print(foo)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; <span class="number">5</span> -&gt; fum</span><br><span class="line">&gt; print(fum)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="列出所有变量">列出所有变量</h2><h3 id="问题-2">问题</h3><p>你希望知道目前工作空间中存在哪些已定义的变量和函数。</p>
<h3 id="解决方案-2">解决方案</h3><p>使用ls函数，或者使用ls.str函数了解每个变量更详细的信息。</p>
<h3 id="讨论-2">讨论</h3><p>ls函数可以显示当前工作空间中所有对象的名称：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">10</span></span><br><span class="line">&gt; y &lt;- <span class="number">50</span></span><br><span class="line">&gt; z &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="string">"three"</span>, <span class="string">"blind"</span>, <span class="string">"mice"</span>)</span></span></span><br><span class="line">&gt; f &lt;- <span class="function"><span class="title">function</span><span class="params">(n,p)</span></span> <span class="function"><span class="title">sqrt</span><span class="params">(p*(<span class="number">1</span>-p)</span></span>/n)</span><br><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">()</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，ls函数输出的结果是一个字符串向量，其中向量的每个元素代表一个变量名。当工作空间中没有已定义的变量时，函数ls会返回一个空向量，它会产生如下令人迷惑的结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">character</span><span class="params">(<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>事实上，R软件采用这样的方式向用户说明，ls函数返回一个长度为0的字符串向量；即工作空间中不含有任何已定义变量。</p>
<p>如果你除了变量名称以外还想对变量有更多的了解，那么你可以使用ls.str函数，该函数会返回变量的一些其他信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls.str()</span><br><span class="line">f : function (n, p)</span><br><span class="line">x :  num <span class="number">10</span></span><br><span class="line">y :  num <span class="number">50</span></span><br><span class="line">z :  chr [<span class="number">1</span>:<span class="number">3</span>] <span class="string">"three"</span> <span class="string">"blind"</span> <span class="string">"mice"</span></span><br></pre></td></tr></table></figure>
<p>ls.str函数之所以写为ls.str，原因在于其功能既显示了所有变量的名称，又对所有变量使用了str函数，方法12.15对此进行了详细的说明。</p>
<p>ls函数不会显示以点（.）开头的变量名，以点开头的变量一般作为隐藏变量不为用户所知（这一输出规定来源于UNIX系统）。在R软件中，可以通过将ls.str函数中的all.names参数设定为TRUE，强制列出所有变量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class">.hidvar</span> &lt;- <span class="number">10</span></span><br><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">()</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">(all.names=TRUE)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">".hidvar"</span> <span class="string">"f"</span>       <span class="string">"x"</span>       <span class="string">"y"</span>       <span class="string">"z"</span></span><br></pre></td></tr></table></figure>
<h2 id="删除变量">删除变量</h2><h3 id="问题-3">问题</h3><p>你希望删除工作空间中不需要的变量和函数，或者完全删除它们的取值内容。</p>
<h3 id="解决方案-3">解决方案</h3><p>使用rm函数。</p>
<h3 id="讨论-3">讨论</h3><p>在R软件的使用过程中，工作空间容易很快变得杂乱。rm函数能永久地从工作空间中删除一个或多个对象：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">2</span>*pi</span><br><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">6.283185</span></span><br><span class="line">&gt; <span class="function"><span class="title">rm</span><span class="params">(x)</span></span></span><br><span class="line">&gt; x</span><br><span class="line">Error: <span class="tag">object</span> <span class="string">"x"</span> not found</span><br></pre></td></tr></table></figure>
<p>该命令无法“撤销”，即删除的变量无法找回。</p>
<p>你可以通过如下命令同时删除多个变量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">rm</span><span class="params">(x,y,z)</span></span></span><br></pre></td></tr></table></figure>
<p>你甚至可以同时删除工作空间中所有的内容。rm函数中有一个list参数，它包含所有需要删除的变量名称。前面章节介绍过ls函数能返回所有变量名称，因此你可以通过结合rm函数与ls函数，删除工作空间中的所有变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls()</span><br><span class="line">[<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br><span class="line">&gt; rm(list=ls())</span><br><span class="line">&gt; ls()</span><br><span class="line">character(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>R软件的道德规范</code>在与他人共享代码时，绝不能将带有<code>rm(list=ls())</code>的恶意代码通过网络示例或者其他方法发送至他人。用此手段删除对方工作空间中所有的内容是如此粗鄙的行为，让你变得不受欢迎</p>
<h2 id="生成向量">生成向量</h2><h3 id="问题-4">问题</h3><p>如何生成一个向量。</p>
<h3 id="解决方案-4">解决方案</h3><p>通过<code>c(...)</code>命令对给定的值构建一个向量。</p>
<h3 id="讨论-4">讨论</h3><p>向量不仅是R的一种数据结构，它还是贯通R软件的重要组成部分。向量中可以包含数值、字符串或者逻辑值，但不能由多种格式混合组成。</p>
<p>在<code>c(...)</code>命令中添加元素对向量进行赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span></span><br><span class="line">&gt; c(<span class="number">1</span>*pi, <span class="number">2</span>*pi, <span class="number">3</span>*pi, <span class="number">4</span>*pi)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">3.141593</span>  <span class="number">6.283185</span>  <span class="number">9.424778</span> <span class="number">12.566371</span></span><br><span class="line">&gt; c(<span class="string">"Everyone"</span>, <span class="string">"loves"</span>, <span class="string">"stats."</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"Everyone"</span> <span class="string">"loves"</span>    <span class="string">"stats."</span></span><br><span class="line">&gt; c(TRUE,TRUE,FALSE,TRUE)</span><br><span class="line">[<span class="number">1</span>]  TRUE  TRUE FALSE  TRUE</span><br></pre></td></tr></table></figure>
<p>如果c(…) 中的参数自身是向量，那么c(…) 命令会将多个向量合为一个向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1 &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt; v2 &lt;- c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">&gt; c(v1,v2)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>对于一个向量来说，其中的内容不能由多种数据格式混合组成，如在一个向量中同时包含数值和字符串。R软件对于混合型向量会进行如下的格式转换：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1 &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span></span><br><span class="line">&gt; v3 &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>)</span></span></span><br><span class="line">&gt; <span class="function"><span class="title">c</span><span class="params">(v1,v3)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"1"</span> <span class="string">"2"</span> <span class="string">"3"</span> <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span></span><br></pre></td></tr></table></figure>
<p>这里，用户希望将一组数值数据和一组字符串数据同时赋值给一个新的向量。对于这种情况，R软件会先将数值数据转换为字符串数据，使得两组数据的类型得以统一。</p>
<p>理论上来说，两组数据能同时赋值于一个向量的条件，在于两组数据具有相同的类型 （mode）。例如3.1415和”foo”分别为数值型和字符型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; mode(<span class="number">3.1415</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br><span class="line">&gt; mode(<span class="string">"foo"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"character"</span></span><br></pre></td></tr></table></figure>
<p>上述两者的类型不同。为了生成新的向量，R软件将3.1415转换为字符类型，使得3.1415的类型与”foo”的类型一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; c(<span class="number">3.1415</span>, <span class="string">"foo"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"3.1415"</span> <span class="string">"foo"</span></span><br><span class="line">&gt; mode(c(<span class="number">3.1415</span>, <span class="string">"foo"</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="string">"character"</span></span><br></pre></td></tr></table></figure>
<p><code>警告</code>：c是一个通用的运算符，这意味着它不仅应用于向量，同时也应用于其他的数据类型。但是，它可能不是那么精确地与用户预期相一致。因此在将c命令用于其他数据类型和对象前，要查看它的效果。</p>
<h2 id="计算基本统计量">计算基本统计量</h2><h3 id="问题-5">问题</h3><p>如何使用R软件计算下列统计量：均值、中位数、标准差、方差、协方差和相关系数。</p>
<h3 id="解决方案-5">解决方案</h3><p>采用如下函数进行计算，其中x、y均为向量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mean</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">median</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">sd</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">var</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(x, y)</span></span></span><br><span class="line"><span class="function"><span class="title">cov</span><span class="params">(x, y)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="讨论-5">讨论</h3><p>我初次阅读R软件帮助文件是为了寻找“标准差的计算过程”这一内容，原本认为帮助文件会以一整章篇幅介绍这一重要概念。</p>
<p>实际上没有那么复杂。</p>
<p>R软件中，用简单的函数便能完成标准差和其他基本统计量的计算。一般来说，函数参数是一个数值向量，而函数返回计算出的统计量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; mean(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.8</span></span><br><span class="line">&gt; median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">&gt; sd(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">11.03328</span></span><br><span class="line">&gt; var(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">121.7333</span></span><br></pre></td></tr></table></figure>
<p>其中sd函数计算样本标准差，var函数计算样本方差。</p>
<p>cor函数以及cov函数分别计算两变量间的相关系数与协方差：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; y &lt;- log(x+<span class="number">1</span>)</span><br><span class="line">&gt; cor(x,y)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9068053</span></span><br><span class="line">&gt; cov(x,y)</span><br><span class="line">[<span class="number">1</span>] <span class="number">11.49988</span></span><br></pre></td></tr></table></figure>
<p>上述函数对于是否存在缺失值（NA）很敏感。某个变量中的一个缺失值就有可能导致函数返回NA结果，甚至可能造成计算机在计算过程中报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,NA)</span><br><span class="line">&gt; mean(x)</span><br><span class="line">[<span class="number">1</span>] NA</span><br><span class="line">&gt; sd(x)</span><br><span class="line">[<span class="number">1</span>] NA</span><br></pre></td></tr></table></figure>
<p>虽然R软件对于缺失值的敏感程度有时会造成用户的不便，但这种处理方式也是合情合理的。对于R软件返回的结果你应该慎重地考虑：数据中的缺失值是否会严重影响统计结果？如果是，那么R软件返回错误结果是正确的；如果不是，则可以通过设置参数na.rm=TRUE, 告知R软件忽略缺失值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,NA)</span><br><span class="line">&gt; mean(x, na.rm=TRUE)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.4</span></span><br><span class="line">&gt; sd(x, na.rm=TRUE)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.140175</span></span><br></pre></td></tr></table></figure>
<p>mean函数和sd函数能巧妙地处理数据框数据，自动将数据框中的每一列认为是不同的变量，并对每列数据分别进行计算。下面的例子展示了mean和sd函数对有三列的数据框的计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(dframe)</span><br><span class="line">       small    mediumbig</span><br><span class="line"><span class="number">1</span>  <span class="number">0.6739635</span>  <span class="number">10.526448</span>   <span class="number">99.83624</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.5524619</span>   <span class="number">9.205156</span>  <span class="number">100.70852</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.3250562</span>  <span class="number">11.427756</span>   <span class="number">99.73202</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.2143595</span>   <span class="number">8.533180</span>   <span class="number">98.53608</span></span><br><span class="line"><span class="number">5</span>  <span class="number">1.3107692</span>   <span class="number">9.763317</span>  <span class="number">100.74444</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2.1739663</span>   <span class="number">9.806662</span>   <span class="number">98.58961</span></span><br><span class="line"><span class="number">7</span>  <span class="number">1.6187899</span>   <span class="number">9.150245</span>  <span class="number">100.46707</span></span><br><span class="line"><span class="number">8</span>  <span class="number">0.8872657</span>  <span class="number">10.058465</span>   <span class="number">99.88068</span></span><br><span class="line"><span class="number">9</span>  <span class="number">1.9170283</span>   <span class="number">9.182330</span>  <span class="number">100.46724</span></span><br><span class="line"><span class="number">10</span> <span class="number">0.7767406</span>   <span class="number">7.949692</span>  <span class="number">100.49814</span></span><br><span class="line">&gt; mean(dframe)</span><br><span class="line">   small    medium       big</span><br><span class="line"><span class="number">1.245040</span>  <span class="number">9.560325</span> <span class="number">99.946003</span></span><br><span class="line">&gt; sd(dframe)</span><br><span class="line">    small    medium       big</span><br><span class="line"><span class="number">0.5844025</span> <span class="number">0.9920281</span> <span class="number">0.8135498</span></span><br></pre></td></tr></table></figure>
<p>注意，mean和sd函数都会返回3个值，每个数值对应着对数据框中一列数据的计算结果（一般地，R软件会以一个包含三个元素的向量返回结果，其中每个元素的names属性由数据框中各个列的名称得来）。</p>
<p>var函数也能处理数据框数据，但处理方式与mean函数和sd函数有些许不同。var函数计算每两列变量间的协方差，并以协方差矩阵的形式返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; var(dframe)</span><br><span class="line">             small      medium         big</span><br><span class="line">small   <span class="number">0.34152627</span> -<span class="number">0.21516416</span> -<span class="number">0.04005275</span></span><br><span class="line">medium -<span class="number">0.21516416</span>  <span class="number">0.98411974</span> -<span class="number">0.09253855</span></span><br><span class="line">big    -<span class="number">0.04005275</span> -<span class="number">0.09253855</span>  <span class="number">0.66186326</span></span><br></pre></td></tr></table></figure>
<p>同样，如果x是一个数据框或矩阵，则<code>cor(x)</code> 返回其相关系数矩阵；而<code>cov(x)</code> 返回其协方差矩阵：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; cor(dframe)</span><br><span class="line">             small     medium         big</span><br><span class="line">small   <span class="number">1.00000000</span> -<span class="number">0.3711367</span> -<span class="number">0.08424345</span></span><br><span class="line">medium -<span class="number">0.37113670</span>  <span class="number">1.0000000</span> -<span class="number">0.11466070</span></span><br><span class="line">big    -<span class="number">0.08424345</span> -<span class="number">0.1146607</span>  <span class="number">1.00000000</span></span><br><span class="line">&gt; cov(dframe)</span><br><span class="line">             small      medium         big</span><br><span class="line">small   <span class="number">0.34152627</span> -<span class="number">0.21516416</span> -<span class="number">0.04005275</span></span><br><span class="line">medium -<span class="number">0.21516416</span>  <span class="number">0.98411974</span> -<span class="number">0.09253855</span></span><br><span class="line">big    -<span class="number">0.04005275</span> -<span class="number">0.09253855</span>  <span class="number">0.66186326</span></span><br></pre></td></tr></table></figure>
<p><code>median</code>函数无法辨认数据框形式的数据。若需计算数据框数据的中位数，需要使用方法6.4对各列分别进行计算。</p>
<h2 id="生成数列">生成数列</h2><h3 id="问题-6">问题</h3><p>如何生成一个数列。</p>
<h3 id="解决方案-6">解决方案</h3><p>使用表达式<code>n:m</code>生成简单数列n,n+1,n+2,…,m：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>对于增量不为1的数列，可以使用<code>seq</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">1</span>, to=<span class="number">5</span>, by=<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>使用rep函数生成由一个数的重复所组成的数列：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(<span class="number">1</span>, times=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="讨论-6">讨论</h3><p>冒号运算符<code>（n:m）</code>会生成包含n,n+1,n+2,…,m的一个向量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span>:<span class="number">9</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">&gt; <span class="number">10</span>:<span class="number">19</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span></span><br><span class="line">&gt; <span class="number">9</span>:<span class="number">0</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，上述最后一个表达式（9:0），R软件能自动识别9大于0并以递减的形式生成数列。</p>
<p>冒号运算符仅能生成增量为1的数列。而seq函数通过它的第三个参数来规定数列元素的增量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>, by=<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>, by=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>相应地，你可以在函数中规定输出数列的长度，R软件会自动识别并根据要求生成等增量数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>, length.out=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span></span><br><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">100</span>, length.out=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]   <span class="number">0</span>  <span class="number">25</span>  <span class="number">50</span>  <span class="number">75</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>函数seq的增量参数并非一定是整数。R软件也可以生成具有分数增量的数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">1.0</span>, to=<span class="number">2.0</span>, length.out=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.00</span> <span class="number">1.25</span> <span class="number">1.50</span> <span class="number">1.75</span> <span class="number">2.00</span></span><br></pre></td></tr></table></figure>
<p>特殊情况下，若需要生成重复某个值的数列，则可以使用rep函数，生成的数列重复其第一个参数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(pi, times=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.141593</span> <span class="number">3.141593</span> <span class="number">3.141593</span> <span class="number">3.141593</span> <span class="number">3.141593</span></span><br></pre></td></tr></table></figure>
<h2 id="向量比较">向量比较</h2><h3 id="问题-7">问题</h3><p>如何比较两个向量，或者将一个向量的所有元素与某一个常数进行比较。</p>
<h3 id="解决方案-7">解决方案</h3><p>比较运算符（==、!=、&lt;、&gt;、&lt;=、&gt;=）能对两向量间的各个元素进行比较。这些运算符也能将向量中所有元素与一个常数进行比较。返回结果是每两个元素间比较结果的逻辑值向量。</p>
<h3 id="讨论-7">讨论</h3><p>R软件包含两个逻辑值，TRUE和FALSE。在其他编程语言中也称为布尔值（Boolean values）。</p>
<p>比较运算符通过比较两个值，并根据比较结果返回TRUE或FALSE：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; a &lt;- 3</span><br><span class="line">&gt; a == pi     # 检验两者是否相等</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; a != pi     # 检验两者是否不等</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; a &lt; pi</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; a &gt; pi</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; a &lt;= pi</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; a &gt;= pi</span><br><span class="line">[1] FALSE</span><br></pre></td></tr></table></figure>
<p>你可以使用R软件一次性地对两个向量进行比较，它会将两个向量中每两个对应的元素进行比较，并以逻辑值向量方式返回比较结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c( 3, pi,  4)</span><br><span class="line">&gt; w &lt;- c(pi, pi, pi)</span><br><span class="line">&gt; v == w# 比较两个各自包含3个元素的向量</span><br><span class="line">[1] FALSE  TRUE FALSE# 结果以包含3个逻辑值的向量形式输出</span><br><span class="line">&gt; v != w</span><br><span class="line">[1]  TRUE FALSE  TRUE</span><br><span class="line">&gt; v &lt; w</span><br><span class="line">[1]  TRUE FALSE FALSE</span><br><span class="line">&gt; v &lt;= w</span><br><span class="line">[1]  TRUE  TRUE FALSE</span><br><span class="line">&gt; v &gt; w</span><br><span class="line">[1] FALSE FALSE  TRUE</span><br><span class="line">&gt; v &gt;= w</span><br><span class="line">[1] FALSE  TRUE  TRUE</span><br></pre></td></tr></table></figure>
<p>也可以将一个向量与一个常数进行比较，R软件会将常数扩充为一组长度与所比较向量的长度相等，并由常数值重复组成的向量，再将新向量与它需要比较向量的对应元素进行比较。所以，之前的例子可以简化为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(3, pi, 4)</span><br><span class="line">&gt; v == pi# 将包含3个元素的向量与一个常数进行比较</span><br><span class="line">[1] FALSE  TRUE FALSE</span><br><span class="line">&gt; v != pi</span><br><span class="line">[1]  TRUE FALSE  TRUE</span><br></pre></td></tr></table></figure>
<p>比较两个向量后，你通常会想知道比较结果中是否存在TRUE，或者比较结果是否全为TRUE。可以应用函数any和all来检验上述问题。两个函数都针对逻辑型变量进行检验，其中如果元素中含有至少一个TRUE，则any函数返回TRUE；如果元素全为TRUE，则all函数返回TRUE：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(3, pi, 4)</span><br><span class="line">&gt; any(v == pi)# 若v向量中元素至少一个等于pi，则返回TRUE</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; all(v == 0)# 若v向量中所有元素都为0，则返回TRUE</span><br><span class="line">[1] FALSE</span><br></pre></td></tr></table></figure>
<h2 id="选取向量中的元素">选取向量中的元素</h2><h3 id="问题:如何选取向量中一个或多个元素。">问题:如何选取向量中一个或多个元素。</h3><h3 id="解决方案-8">解决方案</h3><ul>
<li><p>选择适合问题的索引技术：</p>
</li>
<li><p>根据元素在向量中的位置使用方括号来选出元素，如v[3]代表了v向量中的第三个元素。</p>
</li>
<li><p>索引前加负号（－），排除向量中相应位置的元素。</p>
</li>
<li><p>使用向量索引来选择多个元素值。</p>
</li>
<li><p>使用逻辑向量根据条件来选择元素。</p>
</li>
<li><p>使用名称来选择命名的元素。</p>
</li>
</ul>
<h3 id="讨论-8">讨论</h3><p>从向量中选出某些元素是R的又一项强大功能。和其他编程语言一样，R选取向量元素的基本方法是使用一对方括号和简单索引（下标）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; fib</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span></span><br><span class="line">&gt; fib[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br><span class="line">&gt; fib[<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; fib[<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; fib[<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br><span class="line">&gt; fib[<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，向量第一个元素的索引（或下标）为1，而非某些编程语言中的0。</p>
<p>另外也可以同时选择一个向量中的多个元素，向量的索引本身可以是一个向量，并且根据下标向量中所指定的位置选择原向量中的元素：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[1:3]# 选择下标为1至3的元素</span><br><span class="line">[1] 0 1 1</span><br><span class="line">&gt; fib[4:9]# 选择下标为4至9的元素</span><br><span class="line">[1]  2  3  5  8 13 21</span><br></pre></td></tr></table></figure></p>
<p>1:3这样的下标意味着选择第1、2、3个元素，如上例所示。索引向量可以不是简单数列，可以选择向量数据中的任何元素，如下例所示，它选择第1、2、4和第8个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>R将负索引看做是排除向量中相应索引的元素。如下标为－1，意味着选择除了向量的第一个元素外的所有其他元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[-1]          # 忽略第一个元素</span><br><span class="line">[1]  1  1  2  3  5  8 13 21 34</span><br></pre></td></tr></table></figure>
<p>通过使用负索引的索引向量，该方法可以扩展为排除多个元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[1:3]         # 前述向量</span><br><span class="line">[1] 0 1 1</span><br><span class="line">&gt; fib[-(1:3)]      # 在索引前添加负号，排除相应的元素</span><br><span class="line">[1]  2  3  5  8 13 21 34</span><br></pre></td></tr></table></figure>
<p>还可以使用逻辑向量从数据向量中选择元素。与索引逻辑向量取值为TRUE的元素相对应的原始数据向量的元素将被选择：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib &lt; 10# 仅当向量中元素值小于10时该表达式为TRUE</span><br><span class="line">[1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE</span><br><span class="line">&gt; fib[fib &lt; 10]# 使用该表达式选择向量中小于10的值</span><br><span class="line">[1] 0 1 1 2 3 5 8</span><br><span class="line">&gt; fib %% 2 == 0# 仅当向量fib中元素值为偶数时该表达式为TRUE</span><br><span class="line">[1]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE</span><br><span class="line">&gt; fib[fib %% 2 == 0]# 使用该表达式选择向量中的偶数值</span><br><span class="line">[1]  0  2  8  34</span><br></pre></td></tr></table></figure>
<p>一般地，索引逻辑向量的长度应与原始数据向量的长度相同，这样才能清晰地选择或者排除每一个元素（若两者长度不同，则需要了解循环规则，具体请参见方法5.3）。</p>
<p>结合向量比较、逻辑运算符以及向量索引，可以用少量的R命令来完成强大的选择功能：</p>
<p>选择所有小于中位数的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ v &gt; median(v) ]</span><br></pre></td></tr></table></figure></p>
<p>选择分布于两端5%的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ (v &lt; quantile(v,<span class="number">0.05</span>)) | (v &gt; quantile(v,<span class="number">0.95</span>)) ]</span><br></pre></td></tr></table></figure></p>
<p>选择所有处于均值的两倍标准差区间以外的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ abs(v-mean(v)) &gt; <span class="number">2</span>*sd(v) ]</span><br></pre></td></tr></table></figure></p>
<p>选择所有NA或NULL值的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ !is.na(v) &amp; !is.<span class="keyword">null</span>(v) ]</span><br></pre></td></tr></table></figure></p>
<p>最后一个索引特征可以让你通过名称选择元素。它要求数据向量有name属性，即其中每个元素都定义各自的名称。可以指定一个字符串向量来完成该数据向量名称的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; years &lt;- c(<span class="number">1960</span>, <span class="number">1964</span>, <span class="number">1976</span>, <span class="number">1994</span>)</span><br><span class="line">&gt; names(years) &lt;- c(<span class="string">"Kennedy"</span>, <span class="string">"Johnson"</span>, <span class="string">"Carter"</span>, <span class="string">"Clinton"</span>)</span><br><span class="line">&gt; years</span><br><span class="line">Kennedy Johnson  Carter Clinton</span><br><span class="line">   <span class="number">1960</span>    <span class="number">1964</span>    <span class="number">1976</span>    <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<p>一旦元素的名称已定义，则可以使用名称引用向量中的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; years[<span class="string">"Carter"</span>]</span><br><span class="line">Carter</span><br><span class="line">  <span class="number">1976</span></span><br><span class="line">&gt; years[<span class="string">"Clinton"</span>]</span><br><span class="line">Clinton</span><br><span class="line">   <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<p>可以推广到使用名称来索引向量元素：R软件会返回向量中对应名称的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; years[c(<span class="string">"Carter"</span>,<span class="string">"Clinton"</span>)]</span><br><span class="line">Carter Clinton</span><br><span class="line">  <span class="number">1976</span>    <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<h2 id="向量的计算">向量的计算</h2><h3 id="问题-8">问题</h3><p>你希望对整个向量执行计算。</p>
<h3 id="解决方案-9">解决方案</h3><p>基本的数学运算符可以对向量中的元素进行逐个计算。许多其他的函数也能对向量元素逐个进行运算，并以向量的形式输出结果。</p>
<h3 id="讨论-9">讨论</h3><p>向量计算是R软件的一大特色。所有的基本数学运算符都能应用于向量对中。这些运算符对两个向量中相应的每个元素对进行计算，即将两个向量中对应的元素进行基本运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>)</span><br><span class="line">&gt; w &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&gt; v + w</span><br><span class="line">[<span class="number">1</span>] <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br><span class="line">&gt; v - w</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line">&gt; v * w</span><br><span class="line">[<span class="number">1</span>] <span class="number">11</span> <span class="number">24</span> <span class="number">39</span> <span class="number">56</span> <span class="number">75</span></span><br><span class="line">&gt; v / w</span><br><span class="line">[<span class="number">1</span>] <span class="number">11.000000</span>  <span class="number">6.000000</span>  <span class="number">4.333333</span>  <span class="number">3.500000</span>  <span class="number">3.000000</span></span><br><span class="line">&gt; w ^ v</span><br><span class="line">[<span class="number">1</span>]     <span class="number">1</span>   <span class="number">4096</span>   <span class="number">1594323</span>   <span class="number">268435456</span>  <span class="number">30517578125</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，输出的结果向量的长度与原向量的长度相等。原因是结果向量中的每个元素都是由原向量对中对应的两个元素计算得来。</p>
<p>若使一个向量与一个常数进行运算，则会将该向量的每个元素与常数进行运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; w + <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">&gt; w - <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">&gt; w * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span></span><br><span class="line">&gt; w / <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.5</span> <span class="number">1.0</span> <span class="number">1.5</span> <span class="number">2.0</span> <span class="number">2.5</span></span><br><span class="line">&gt; w ^ <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">4</span>  <span class="number">9</span> <span class="number">16</span> <span class="number">25</span></span><br><span class="line">&gt; <span class="number">2</span> ^ w</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">8</span> <span class="number">16</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>例如，可以在一个表达式中得到一个向量减去其元素均值后的向量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; mean(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; w - mean(w)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">2</span> -<span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样，可以通过计算向量减去其均值并除以其标准差，来获得该向量数据的z分数（z-score）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; sd(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.581139</span></span><br><span class="line">&gt; (w - mean(w)) / sd(w)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">1.2649111</span> -<span class="number">0.6324555</span>  <span class="number">0.0000000</span>  <span class="number">0.6324555</span>  <span class="number">1.2649111</span></span><br></pre></td></tr></table></figure>
<p>向量的运算功能远不止对元素的简单运算。还有许多函数对整个向量进行运算。如sqrt函数和log函数，都可以应用于整个向量中的每个元素，并以向量的形式输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; sqrt(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.000000</span> <span class="number">1.414214</span> <span class="number">1.732051</span> <span class="number">2.000000</span> <span class="number">2.236068</span></span><br><span class="line">&gt; log(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.0000000</span> <span class="number">0.6931472</span> <span class="number">1.0986123</span> <span class="number">1.3862944</span> <span class="number">1.6094379</span></span><br><span class="line">&gt; sin(w)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0.8414710</span>  <span class="number">0.9092974</span>  <span class="number">0.1411200</span> -<span class="number">0.7568025</span> -<span class="number">0.9589243</span></span><br></pre></td></tr></table></figure>
<p>R软件的向量运算有两大优点。第一个最明显的优点是操作的简便性，其他编程软件中需要通过循环才能完成的操作，在R软件中一行命令便可以实现。第二个优点是计算速度快。大多数向量化的运算直接由C语言代码来实现，它比你自己用R写的代码本质上快很多。</p>
<h2 id="运算符优先级问题">运算符优先级问题</h2><h3 id="问题-9">问题</h3><p>R软件输出结果有误，你希望了解问题是否由运算符的优先级所导致的。</p>
<h3 id="解决方案-10">解决方案</h3><p>所有的运算符显示在表2-1中，并以最高优先级至最低优先级的顺序排列。相同优先级的运算符，除特指外皆由从左至右的顺序进行运算。</p>
<p>表2-1：运算符优先级</p>
<p>运算符含义参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ [[               索引方法<span class="number">2.9</span></span><br><span class="line">:: :::             使用名称访问变量</span><br><span class="line">$ @                元素提取、位置提取</span><br><span class="line">^                  指数形式（从右到左）</span><br><span class="line">- +                元素的负、正</span><br><span class="line">:                  创建数列方法<span class="number">2.7</span>，<span class="number">7.14</span></span><br><span class="line">%any%              特殊运算符讨论</span><br><span class="line">* /                乘、除讨论</span><br><span class="line">+ -                加、减</span><br><span class="line">== !=  &lt; &gt; &lt;= &gt;=   比较运算符方法<span class="number">2.8</span></span><br><span class="line">！                 逻辑取反</span><br><span class="line">&amp;  &amp;&amp;              逻辑“与”、 短路“与”</span><br></pre></td></tr></table></figure>
<p>表2-1：运算符优先级（续）<br>运算符含义参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  ||   逻辑 “或”、 短路“或”</span><br><span class="line">~       公式方法<span class="number">11.1</span></span><br><span class="line">-&gt;  -&gt;&gt; 向右赋值方法<span class="number">2.2</span></span><br><span class="line">=       赋值（从右向左）方法<span class="number">2.2</span></span><br><span class="line">&lt;-  &lt;&lt;- 赋值（从右向左）方法<span class="number">2.2</span></span><br></pre></td></tr></table></figure>
<h3 id="讨论-10">讨论</h3><p>用户在R中搞错运算符的优先级是经常遇到的问题。我经常会犯这样的错误，例如我会不假思索地认为表达式0:n－1会生成从0~n－1的数列，但事实并非如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; n &lt;-<span class="number">10</span></span><br><span class="line">&gt; <span class="number">0</span>:n-<span class="number">1</span></span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>该表达式生成－1~n－1的数列，因为R软件将上式理解为(0:n)－1。</p>
<p>你可能不熟悉表2-1中的符号%any%，R中用两个百分号夹带一个符号的形式（%…%）表示一个二元运算符。R中预定义的二元运算符的含义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%   取模</span><br><span class="line">%/%  整除</span><br><span class="line">%*%  矩阵乘积</span><br><span class="line">%in% 右侧变量中包含左侧变量时，为TRUE；否则，为FALSE。</span><br></pre></td></tr></table></figure>
<p>你可以通过%…%记号来定义新的二元运算符，参见方法12.19。此种运算符都具有相同的运算优先级。</p>
<h2 id="定义函数">定义函数</h2><h3 id="问题-10">问题</h3><p>如何定义一个R函数。</p>
<h3 id="解决方案-11">解决方案</h3><p>使用关键字function，并在其后跟随函数参数列表和函数主体。其基本形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(param1, ...., paramN) expr</span><br></pre></td></tr></table></figure>
<p>函数主体可以是一系列表达式，这些表达式需要用大括号括起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(param1, ..., paramN) &#123;</span><br><span class="line">  expr1</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">  exprM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="讨论-11">讨论</h3><p>函数的定义告诉R软件“用何种方式进行计算”。例如，R软件没有内置计算变异系数的函数，因此你可以定义函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cv &lt;- function(x) sd(x)/mean(x)</span><br><span class="line">&gt; cv(<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.5504819</span></span><br></pre></td></tr></table></figure>
<p>第一行定义了名为cv的函数，第二行引用该函数，以1∶10作为其参数x的值。函数对参数应用函数主体中的表达式sd(x)/mean(x)进行计算并返回结果。</p>
<p>定义函数后，我们可以在任何需要函数的地方应用它，例如可以作为lapply函数的第二个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cv &lt;- function(x) sd(x)/mean(x)</span><br><span class="line">&gt; lapply(lst, cv)</span><br></pre></td></tr></table></figure>
<p>函数主体如果包含多行表达式，则需要使用大括号来确定函数内容的起始和结束位置。下面这一函数采用了欧几里德算法计算两个整数的最大公约数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcd &lt;- function(a,b) &#123;</span><br><span class="line">+ <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span>(a)</span><br><span class="line">+ <span class="keyword">else</span> <span class="keyword">return</span>(gcd(b, a %% b))</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>
<p>R软件也允许使用匿名函数，匿名函数是没有函数名称但在单行的语句中很实用的函数。先前的例子中我们提到将cv函数作为lapply函数的一个参数，而若使用匿名函数直接作为lapply函数的参数，则能将原先的命令简化至同一行中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; lapply(lst, function(x) sd(x)/mean(x))</span><br></pre></td></tr></table></figure>
<p>由于本书重点不在于介绍R的编程语言，这里不对R函数编程的细微之处进行解释。下面给出几个需要注意的地方：</p>
<p><code>返回值</code></p>
<p>所有函数都有一个返回值，即函数主体最后一个表达式值。你也可以通过return(expr)命令给出函数的返回值。</p>
<p><code>值调用</code></p>
<p>函数参数是“值调用”——如果你改变了函数中的参数值，改变只是局部的，并不会影响该参数所引用的变量值。</p>
<p><code>局部变量</code></p>
<p>你可以简单地通过赋值来创建一个局部变量，函数结束后该局部变量会消失。</p>
<p><code>条件执行</code></p>
<p>R语法中包含if语句，更多详情可以使用help(Control)命令查看。</p>
<p><code>循环语句</code></p>
<p>R语法中也包括for循环、while循环以及repeat循环语句。更多详情可以使用help(Control)命令查看。</p>
<p><code>全局变量</code></p>
<p> 在函数中，你可以通过&lt;&lt;-操作符来改变全局变量的值，但此种方法不推荐使用。</p>
<p><code>另请参阅</code> 有关如何定义函数，参见《An Introduction to R》（<a href="http://cran.r-project.org/doc/manuals/R-intro.pdf）和《R" target="_blank" rel="external">http://cran.r-project.org/doc/manuals/R-intro.pdf）和《R</a> in a Nutshell》。2.12 定义函数</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。</p>
<p>R语言是在大数据时代被工业界了解和认识的语言，R语言被时代赋予了，挖掘数据价值，发现数据规律，创造数据财富的任务。</p>
<p>R语言也是帮助人们发挥智慧和创造力的最好的生产工具，我们不仅要学好R语言，还要用好R语言，为社会注入更多的创新的生产力。</p>
<p><img src="http://www.idatacamp.com/wordpress/wp-content/uploads/2015/09/14210N40130-194U.jpg" width="67.5%" /></p>
<p>我认为“R是最值得学习的编程语言”。不论你还在读书，还是已经工作，掌握R语言这个工具，找最适合自己的位置，前途将无限量。</p>
<p>本文主要记录了笔者自学R的基础知识点，这里直介绍R的基础入门知识，全文使用RStudio操作</p>]]>
    
    </summary>
    
      <category term="r" scheme="http://yoursite.com/tags/r/"/>
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
</feed>
