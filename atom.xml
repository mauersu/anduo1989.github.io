<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[攻城狮笔记]]></title>
  <subtitle><![CDATA[程序猿开荒野史]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-11-08T12:27:07.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[anduo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[常用的shell脚本记录]]></title>
    <link href="http://yoursite.com/2015/11/08/shell-basics/"/>
    <id>http://yoursite.com/2015/11/08/shell-basics/</id>
    <published>2015-11-08T12:20:27.000Z</published>
    <updated>2015-11-08T12:27:07.000Z</updated>
    <content type="html"><![CDATA[<p>主要记录《Linux Shell 脚本攻略》一书很使用的脚本命令，以备用！</p>
<p><img src="http://i12.tietuku.com/eb3991143e5ec10cs.jpg"></p>
<a id="more"></a>
<h2 id="基础入门命令">基础入门命令</h2><p>1、获取字符串长度<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">length</span> = $&#123;<span class="comment">#var&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>2、获得当前使用的SHELL版本<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="variable">$SHELL</span> 或 echo <span class="variable">$0</span></span><br></pre></td></tr></table></figure></p>
<p>3、使用函数添加系统变量<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepend()&#123; [ -d “<span class="variable">$2</span>”] &amp;&amp; eval <span class="variable">$1</span>=\”<span class="variable">$2</span>\$\&#123;<span class="variable">$1</span>:+’:’\$<span class="variable">$1</span>\&#125;\” &amp;&amp; export <span class="variable">$1</span> ;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">prepend</span> PATH /<span class="preprocessor">opt</span>/myapp/<span class="keyword">bin</span><br><span class="line"></span><span class="label">prepend</span> PATH LD_LIBRARY_PATH /<span class="preprocessor">opt</span>/myapp/<span class="keyword">bin</span></span><br></pre></td></tr></table></figure></p>
<p>4、别名的使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> rm=‘cp <span class="variable">$@</span> ~/backup &amp;&amp; rm <span class="variable">$@</span><span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>5、repeat 函数，运行命令直至执行成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">repeat</span></span>()&#123; <span class="keyword">while</span> :; <span class="keyword">do</span> <span class="variable">$@</span> &amp;&amp; <span class="built_in">return</span>; sleep <span class="number">30</span>; <span class="keyword">done</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="命令之乐">命令之乐</h2><h3 id="文件查找与文件列表">文件查找与文件列表</h3><p>1、根据文件名或者正则表达式进行搜索：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find <span class="special">~</span>/ -name “*.txt” -print</span><br><span class="line">find . <span class="command">\(</span> -iname “example*” -o -name “*.pdf” <span class="command">\)</span> -print</span><br><span class="line">find . -iregex “.*<span class="command">\(</span><span class="command">\.</span>py<span class="command">\|</span><span class="command">\.</span>sh<span class="command">\)</span><span class="formula">$”</span></span><br></pre></td></tr></table></figure></p>
<p>2、否定参数<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . ! -name “*.txt” -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></p>
<p>3、基于目录深度的搜索<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -maxdepth <span class="number">1</span> -name “f*” -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></p>
<p>4、根据文件类型搜索<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> <span class="keyword">d</span> -<span class="keyword">print</span></span><br><span class="line">#文件类型: 普通文件-f、符号链接-<span class="keyword">l</span>、目录-<span class="keyword">d</span>、字符设备-c</span><br></pre></td></tr></table></figure></p>
<p>5、根据文件时间进行搜索<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#-atime  访问时间</span></span><br><span class="line"><span class="preprocessor">#-mtime 修改时间</span></span><br><span class="line"><span class="preprocessor">#-ctime  变化时间</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#打印出在最近7天被访问过的所有文件</span></span><br><span class="line">find . -type f -atime -<span class="number">7</span> -print</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#-amin 访问时长</span></span><br><span class="line"><span class="preprocessor">#-mmin 修改时长</span></span><br><span class="line"><span class="preprocessor">#-cmin 变化时长</span></span><br></pre></td></tr></table></figure></p>
<p>6、基于文件大小搜索(k\M\G)<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> +<span class="number">2</span>k</span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> -<span class="number">2</span>k</span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">size</span> <span class="number">2</span>k</span><br></pre></td></tr></table></figure></p>
<p>7、删除匹配的文件<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> “*.swap” -delete</span><br></pre></td></tr></table></figure></p>
<h3 id="玩转xargs">玩转xargs</h3><p>1、基础<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> example.txt | xarges -<span class="keyword">n</span> 3</span><br></pre></td></tr></table></figure></p>
<p>2、结合find使用xargs<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> “*.txt” -print0 | xarges -<span class="number">0</span> rm -f</span><br></pre></td></tr></table></figure></p>
<p>3、统计源码目录中所有java程序文件的行数<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> source_code_dir_path -<span class="built_in">type</span> f -<span class="built_in">name</span> “*.java” -print0 | xargs -<span class="number">0</span> wc -l</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要记录《Linux Shell 脚本攻略》一书很使用的脚本命令，以备用！</p>
<p><img src="http://i12.tietuku.com/eb3991143e5ec10cs.jpg" /></p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[awk 日志处理]]></title>
    <link href="http://yoursite.com/2015/11/08/awk-log/"/>
    <id>http://yoursite.com/2015/11/08/awk-log/</id>
    <published>2015-11-08T12:04:27.000Z</published>
    <updated>2015-11-08T12:20:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>这两天自己挽起袖子处理日志，终于把AWK给入门了。其实AWK的基本使用，学起来也就半天的时间，之前总是靠同事代劳，惰性呀。</p>
<p>此文仅为菜鸟入门，运维们请勿围观。</p>
<p><img src="http://i13.tietuku.com/a9888f27c9795139s.jpg"></p>
<p><code>本文转载直网络，如有版权问题，请及时与我联系</code></p>
<a id="more"></a>
<p>下面是被处理的日志的示例，不那么标准，但不标准的日志正是标准的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2015</span>-<span class="number">08</span>-<span class="number">20</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">55.600</span>] - [<span class="number">192.168</span><span class="number">.0</span><span class="number">.73</span>/<span class="number">192.168</span><span class="number">.0</span><span class="number">.75</span>:<span class="number">1080</span> com.vip.xxx.MyService_2<span class="number">.0</span> <span class="number">0</span> <span class="number">106046</span> <span class="number">100346</span> <span class="number">90</span>ms <span class="number">110</span>ms]</span><br></pre></td></tr></table></figure>
<h1 id="基本语句">基本语句</h1><p>最基本的语句，以空格做分割，提取所需的列：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> <span class="label">$0</span>,<span class="label">$1</span>,<span class="label">$2</span>,$(NF-1),<span class="label">$NF</span>,<span class="label">$NF</span>-$(NF-1)&#125;’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure>
<h2 id="1-_输入">1. 输入</h2><p>AWK是针对文件或管道中每行输入的处理语言。所以也可以从管道输入:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep “xxx” access.<span class="keyword">log</span> | awk '&#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’</span><br></pre></td></tr></table></figure></p>
<p>但下面这样写就会成为一个Linux老梗的主角，awk不需要不需要cat的。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> access.<span class="keyword">log</span> | awk '&#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>'</span><br></pre></td></tr></table></figure></p>
<h2 id="2-语句定义">2.语句定义</h2><p>可以快速的用单引号’ ’，把所有语句写成一行。</p>
<p>也可以用-f 指定文件，文件里可以任意换行，增加可读性和重用性。</p>
<p>所有执行语句用{}括起来，{}的外面是一些高级的东西比如过滤条件，见后。</p>
<h2 id="3-_列引用">3. 列引用</h2><p>$0代表整行所有数据，$1代表第一列(终于不是程序员数数从0开始了)。</p>
<p>NF是个代表总列数的系统变量，所以$NF代表最后一列，还支持$(NF-1)来表示倒数第二列。</p>
<p>还支持列之间的运算，如$NF-$(NF-1)是最后两列的值相减。</p>
<p>只写一个print 是 print $0的简写，打印整行所有数据。</p>
<h2 id="4-_输入的列分隔符">4. 输入的列分隔符</h2><p>默认以空格做分割符，也可以重新指定，下例指定了’:’<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'&#123;print <span class="variable">$1</span>,<span class="variable">$2</span>&#125;’ access.log</span></span><br></pre></td></tr></table></figure></p>
<p>也可以正则表达式定义多个分割符，下例指定了 ‘-‘ 和 ‘:’<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> -F <span class="string">'[-:]'</span> <span class="string">'&#123;print <span class="variable">$1</span>,<span class="variable">$2</span>&#125;’ access.log</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-_输出的列间隔">5. 输出的列间隔</h2><p>print $1,$2 中间的’,’逗号，代表打印时第1与第2列之间使用默认分隔符号也就是空格，也可以用” ”来定义其他任意的字符：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">print</span> <span class="label">$1</span> <span class="string">"\t"</span> <span class="label">$2</span> <span class="string">" - "</span> <span class="label">$3</span><span class="label">$4xxxxx</span><span class="label">$5&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure>
<p>上例，在第1第2列之间用 tab 分隔，第2第3列之间用” - “分隔，</p>
<p>也可以什么都不写代表中间没分隔，比如第3第4列之间，或者乱写一些字符没用” “括起来，也等于没写，比如第4第5列之间。</p>
<p>数字类型，字符串类型</p>
<p>虽然上例最后两列的值是字符串类型的，带着ms字样，看起来不能做算术运算。</p>
<p>但其实两个列相减时，AWK就会神奇地把它们转换为纯数字。同样，做累计的时候，sum=sum+$NF，也能自动转换为数字。</p>
<p>如果想对某个字符列比较是否大于阀值，先把它转回数字就行了</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sed</span> <span class="string">"s|ms]||g"</span> access.log | awk <span class="string">' <span class="variable">$NF</span>&gt;100 &#123;print&#125;'</span></span><br></pre></td></tr></table></figure>
<p>其实可以简写成下面的样子，性能还比使用sed略快：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk ' <span class="label">$NF</span>*1&gt;100 &#123;<span class="keyword">print</span>&#125;’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk ' int(<span class="label">$NF</span>)&gt;100 &#123;<span class="keyword">print</span>&#125;’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<h1 id="BEGIN与END语句">BEGIN与END语句</h1><p>BEGIN与END后的语句定义在处理全部文本内容之前与之后的语句。</p>
<h2 id="1-计算累计值和平均值">1.计算累计值和平均值</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">sum</span>+=<span class="label">$NF&#125;</span> END &#123;<span class="keyword">print</span> <span class="keyword">sum</span>, <span class="keyword">sum</span>/NR&#125;'</span><br></pre></td></tr></table></figure>
<p>上例对每行输入内容进行最后一列的值的累计，而END后的语句，打印累计结果 和平均值，NR是系统变量代表总行数。</p>
<h2 id="2-打印表头">2.打印表头</h2><p>还可以定义BEGIN语句打印表头，定义变量什么的。<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN&#123;<span class="literal">print</span> <span class="string">"Date\t\tTime\t\tCost”&#125; &#123;print <span class="variable">$1</span> "</span>\t<span class="string">"<span class="variable">$2</span> "</span>\t<span class="string">" <span class="variable">$NF</span>&#125;’ access.log</span></span><br></pre></td></tr></table></figure></p>
<p>上例表头用两个制表符分隔，内容则用一个制表符分隔，有良好的对齐效果。</p>
<h1 id="过滤行">过滤行</h1><h2 id="1-_简单字符匹配">1. 简单字符匹配</h2><p>先用grep过滤也是可以的，也可以用awk简单在执行语句之外的/ /之间定义正则表达式<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/192.168.0.4[1-5]/ &#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "192.168.0.4[1-5]” access.<span class="keyword">log</span>｜ awk ‘&#123;<span class="keyword">print</span> <span class="label">$1&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-_针对某一列的字符匹配">2. 针对某一列的字符匹配</h2><p>针对第4列的地址段匹配，~ 是字符匹配，!~则是不匹配的意思。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> <span class="string">'<span class="variable">$4</span> ~ /192.168.0.4[1-5]/ &#123;print&#125;'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-_针对数值的过滤">3. 针对数值的过滤</h2><p>支持==, !=， , &gt;, =, &gt;=<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> <span class="string">'$(NF-1)*1==100 &#123;print&#125;'</span></span><br><span class="line">awk <span class="string">'<span class="variable">$NF</span>-$(NF－1)&gt;100 &#123;print&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>见前，对于非纯数字的字段，可以用算术运算让它转回数字。</p>
<h2 id="4-_多条件同时存在">4. 多条件同时存在</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> <span class="string">'(<span class="variable">$12</span> &gt;150 || $(13)&gt;250) &#123;print&#125;'</span></span><br></pre></td></tr></table></figure>
<h2 id="5-_使用if语句">5. 使用if语句</h2><p>如果逻辑更复杂，可以考虑使用if,else等语句<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123; <span class="flow">if</span> ($(NF-<span class="number">1</span>)*<span class="number">1</span>&gt;<span class="number">100</span>) <span class="built_in">print</span>&#125;'</span><br></pre></td></tr></table></figure></p>
<h1 id="其他">其他</h1><h2 id="1-外部传入参数">1.外部传入参数</h2><p>比如从外面传入超时的阀值，注意threshold在命令行中的位置。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;<span class="keyword">if</span>($(NF)*1&gt;threshold) <span class="keyword">print</span>&#125;' threshold=20 access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-常用函数">2.常用函数</h2><p>最有用是gsub和sub，match，index等。其中gsub将一个字符串替换为目标字符串，可选定整行替换或只替换某一列。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;gsub(<span class="string">"ms]"</span>,<span class="string">""</span>,<span class="label">$NF</span>); <span class="keyword">if</span>( <span class="label">$NF</span>&gt;100 ) <span class="keyword">print</span>&#125;' access.<span class="literal">log</span></span><br></pre></td></tr></table></figure>
<h1 id="一些例子">一些例子</h1><h2 id="1-截取日期段内段数据">1.截取日期段内段数据</h2><p>方式有很多，都是随着日志格式不同自由发挥。</p>
<p>比如下段截取17:30:30 秒到 17.31:00的数据，先抽取出时分秒三列，再拼成一个数字进行比较<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">awk</span> -F <span class="string">"[ :.]"</span> <span class="string">'<span class="variable">$2</span><span class="variable">$3</span><span class="variable">$4</span>&gt;=173030 <span class="variable">$2</span><span class="variable">$3</span><span class="variable">$4173100</span> &#123;print&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>也可以匹配某个整点时间， 下例取11点的日志:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/[2015-08-20 11:/ &#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<p>取11点01分到05分的数据:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '/[2015-08-20 11:0[1-5]:/ &#123;<span class="keyword">print</span> <span class="label">$1&#125;</span>’ access.<span class="literal">log</span></span><br></pre></td></tr></table></figure></p>
<h1 id="2-_找出超时的数据集中发生的时间">2. 找出超时的数据集中发生的时间</h1><p>第一段找出超时记录，第二段过滤掉时间戳里的微秒，然后按秒来合并，并统计该秒超时的次数。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'$(NF)*1&gt;100 &#123;print&#125;’ access.log | awk -F"." '</span>&#123;print <span class="variable">$1</span>&#125;<span class="string">' | sort | uniq -c</span></span><br></pre></td></tr></table></figure></p>
<p>————- END ——————–</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>这两天自己挽起袖子处理日志，终于把AWK给入门了。其实AWK的基本使用，学起来也就半天的时间，之前总是靠同事代劳，惰性呀。</p>
<p>此文仅为菜鸟入门，运维们请勿围观。</p>
<p><img src="http://i13.tietuku.com/a9888f27c9795139s.jpg" /></p>
<p><code>本文转载直网络，如有版权问题，请及时与我联系</code></p>]]>
    
    </summary>
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[R语言实现之决策树]]></title>
    <link href="http://yoursite.com/2015/11/08/r-ctree/"/>
    <id>http://yoursite.com/2015/11/08/r-ctree/</id>
    <published>2015-11-07T19:07:43.000Z</published>
    <updated>2015-11-07T19:50:23.000Z</updated>
    <content type="html"><![CDATA[<div class="note"><br>  <h5>决策树</h5><br>  <p>决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。</p><br></div>


<p>这一节学习使用包<code>party</code>里面的函数ctree()为数据集iris建立一个<code>决策树</code>。属性<code>Sepal.Length</code>（萼片长度）、<code>Sepal.Width</code>（萼片宽度）、<code>Petal.Length</code>（花瓣长度）以及<code>Petal.Width</code>（花瓣宽度）被用来预测鸢尾花的<code>Species</code>（种类）。在这个包里面，函数ctree()建立了一个决策树，predict()预测另外一个数据集。</p>
<p>在建立模型之前，iris（鸢尾花）数据集被分为两个子集：训练集（70%）和测试集（30%）。使用随机种子设置固定的随机数，可以使得随机选取的数据是可重复利用的。</p>
<a id="more"></a>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 导入构建决策树所需要的库</span></span><br><span class="line">&gt;<span class="keyword">library</span>(<span class="string">"party"</span>)<span class="comment">#导入数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本次构建决策树所用的数据源</span></span><br><span class="line">&gt;str(iris)<span class="comment">#集中展示数据文件的结构</span></span><br><span class="line"><span class="string">'data.frame'</span>: <span class="number">150</span> obs. of <span class="number">5</span> variables: <span class="number">150</span>条观测值，<span class="number">5</span>个变量</span><br><span class="line">$ Sepal.Length: num <span class="number">5.1</span> <span class="number">4.9</span> <span class="number">4.7</span> <span class="number">4.6</span> <span class="number">5</span> <span class="number">5.4</span> <span class="number">4.6</span> <span class="number">5</span> <span class="number">4.4</span> <span class="number">4.9</span> <span class="keyword">...</span></span><br><span class="line">$ Sepal.Width : num <span class="number">3.5</span> <span class="number">3</span> <span class="number">3.2</span> <span class="number">3.1</span> <span class="number">3.6</span> <span class="number">3.9</span> <span class="number">3.4</span> <span class="number">3.4</span> <span class="number">2.9</span> <span class="number">3.1</span> <span class="keyword">...</span></span><br><span class="line">$ Petal.Length: num <span class="number">1.4</span> <span class="number">1.4</span> <span class="number">1.3</span> <span class="number">1.5</span> <span class="number">1.4</span> <span class="number">1.7</span> <span class="number">1.4</span> <span class="number">1.5</span> <span class="number">1.4</span> <span class="number">1.5</span> <span class="keyword">...</span></span><br><span class="line">$ Petal.Width : num <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.4</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="keyword">...</span></span><br><span class="line">$ Species : Factor w/ <span class="number">3</span> levels <span class="string">"setosa"</span>,<span class="string">"versicolor"</span>,..: <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="keyword">...</span></span><br><span class="line"> </span><br><span class="line">Call <span class="keyword">function</span> ctree to build a decision tree. The first parameter is a formula, which defines a target variable and a list of independent variables.</span><br><span class="line"></span><br><span class="line"><span class="comment">#  函数构建决策树</span></span><br><span class="line">&gt;iris_ctree&lt;-ctree(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data=iris)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看决策树的具体信息</span></span><br><span class="line">&gt;print(iris_ctree)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 决策树案例拟合图</span></span><br><span class="line">Conditional inference tree with <span class="number">4</span> terminal nodes</span><br><span class="line"></span><br><span class="line">Response:  Species </span><br><span class="line">Inputs:  Sepal.Length, Sepal.Width, Petal.Length, Petal.Width </span><br><span class="line">Number of observations:  <span class="number">150</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) Petal.Length &lt;= <span class="number">1.9</span>; criterion = <span class="number">1</span>, statistic = <span class="number">140.264</span></span><br><span class="line">  <span class="number">2</span>)*  weights = <span class="number">50</span> </span><br><span class="line"><span class="number">1</span>) Petal.Length &gt; <span class="number">1.9</span></span><br><span class="line">  <span class="number">3</span>) Petal.Width &lt;= <span class="number">1.7</span>; criterion = <span class="number">1</span>, statistic = <span class="number">67.894</span></span><br><span class="line">    <span class="number">4</span>) Petal.Length &lt;= <span class="number">4.8</span>; criterion = <span class="number">0.999</span>, statistic = <span class="number">13.865</span></span><br><span class="line">      <span class="number">5</span>)*  weights = <span class="number">46</span> </span><br><span class="line">    <span class="number">4</span>) Petal.Length &gt; <span class="number">4.8</span></span><br><span class="line">      <span class="number">6</span>)*  weights = <span class="number">8</span> </span><br><span class="line">  <span class="number">3</span>) Petal.Width &gt; <span class="number">1.7</span></span><br><span class="line">    <span class="number">7</span>)*  weights = <span class="number">46</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制构建完的决策树图</span></span><br><span class="line">&gt;plot(iris_ctree)</span><br></pre></td></tr></table></figure>
<p>未剪枝的决策树图<br><img src="http://i12.tietuku.com/f59a8fd34a6eb6eas.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对该决策树进行适当的剪枝，防止过拟合，使得树能够较好地反映数据内在的规律并在实际应用中有意义</span></span><br><span class="line">&gt;plot(iris_ctree, <span class="built_in">type</span>=<span class="string">"simple"</span>)</span><br></pre></td></tr></table></figure>
<p>决策树案例拟合图<br><img src="http://i12.tietuku.com/7665e4093ba82183s.png"></p>
<p>在图1中，每一个叶子的节点的条形图都显示了观测值落入三个品种的概率。在图2中，这些概率以每个叶子结点中的y值表示。例如：结点2里面的标签是“n=50 y=(1,0,0)”，指的是这一类中一共有50个观测值，并且所有的观测值的类别都属于第一类setosa（山鸢尾）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<div class="note"><br>  <h5>决策树</h5><br>  <p>决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。</p><br></div>


<p>这一节学习使用包<code>party</code>里面的函数ctree()为数据集iris建立一个<code>决策树</code>。属性<code>Sepal.Length</code>（萼片长度）、<code>Sepal.Width</code>（萼片宽度）、<code>Petal.Length</code>（花瓣长度）以及<code>Petal.Width</code>（花瓣宽度）被用来预测鸢尾花的<code>Species</code>（种类）。在这个包里面，函数ctree()建立了一个决策树，predict()预测另外一个数据集。</p>
<p>在建立模型之前，iris（鸢尾花）数据集被分为两个子集：训练集（70%）和测试集（30%）。使用随机种子设置固定的随机数，可以使得随机选取的数据是可重复利用的。</p>]]>
    
    </summary>
    
      <category term="r" scheme="http://yoursite.com/tags/r/"/>
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[R语言基础知识]]></title>
    <link href="http://yoursite.com/2015/11/08/r-basics/"/>
    <id>http://yoursite.com/2015/11/08/r-basics/</id>
    <published>2015-11-07T17:25:14.000Z</published>
    <updated>2015-11-07T18:41:58.000Z</updated>
    <content type="html"><![CDATA[<p>R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。</p>
<p>R语言是在大数据时代被工业界了解和认识的语言，R语言被时代赋予了，挖掘数据价值，发现数据规律，创造数据财富的任务。</p>
<p>R语言也是帮助人们发挥智慧和创造力的最好的生产工具，我们不仅要学好R语言，还要用好R语言，为社会注入更多的创新的生产力。</p>
<p><img src="http://www.idatacamp.com/wordpress/wp-content/uploads/2015/09/14210N40130-194U.jpg"></p>
<p>我认为“R是最值得学习的编程语言”。不论你还在读书，还是已经工作，掌握R语言这个工具，找最适合自己的位置，前途将无限量。</p>
<p>本文主要记录了笔者自学R的基础知识点，这里直介绍R的基础入门知识，全文使用RStudio操作</p>
<a id="more"></a>
<h3 id="目录">目录</h3><ul>
<li>显示内容</li>
<li>设置变量</li>
<li>生成向量</li>
<li>基本统计量的计算</li>
<li>数列生成</li>
<li>向量比较、操作</li>
<li>函数定义</li>
</ul>
<div class="note"><br>  <h5>显示内容</h5><br>  <p>问题:如何通过R软件显示某一变量或表达式的值。</p><br></div><br>### 解决方案<br><br>在提示符后直接输入变量名或表达式，R软件便会直接在屏幕中输出其值。使用print函数能输出所有的变量和表达式值，使用cat函数则能选择以用户自定义的格式显示对象的值。<br><br>### 讨论<br><br>通过R软件显示结果的步骤很简单：只需在提示符后输入变量名或表达式：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; pi</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.141593</span></span><br><span class="line">&gt; <span class="built_in">sqrt</span>(<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.414214</span></span><br></pre></td></tr></table></figure><br><br>当输入如上表达式后，R软件会对表达式进行计算并自动调用print函数显示结果。因此上述命令等同于如下命令：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(pi)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.141593</span></span><br><span class="line">&gt; print(<span class="built_in">sqrt</span>(<span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.414214</span></span><br></pre></td></tr></table></figure><br><br>print函数的优点在于它知道该以何种格式显示结果，包括一些具有格式的变量，如矩阵和列表：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span></span><br><span class="line">&gt; print(<span class="built_in">list</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>))</span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"a"</span></span><br><span class="line">[[<span class="number">2</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"b"</span></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="string">"c"</span></span><br></pre></td></tr></table></figure><br><br>这一命令很常用，因为你可以随时通过print函数显示数据，而不必在意数据显示的顺序与逻辑，即使对如矩阵这样复杂的数据格式也是如此。<br><br>但print函数也有其局限性：print函数每次只能显示一个对象。同时显示多个变量会得到如下结果：<br><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">print</span><span class="params">(<span class="string">"The zero occurs at"</span>, <span class="number">2</span>*pi, <span class="string">"radians."</span>)</span></span></span><br><span class="line">Error <span class="keyword">in</span> print.<span class="function"><span class="title">default</span><span class="params">(<span class="string">"The zero occurs at"</span>, <span class="number">2</span> * pi, <span class="string">"radians."</span>)</span></span> :  unimplemented type <span class="string">'character'</span> <span class="keyword">in</span> <span class="string">'asLogical'</span></span><br></pre></td></tr></table></figure><br><br>只有通过多次使用print函数才能显示多个对象，但用户往往会认为这种方法过于繁琐：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(<span class="string">"The zero occurs at"</span>); print(<span class="number">2</span>*pi); print(<span class="string">"radians"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"The zero occurs at"</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">6.283185</span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"radians"</span></span><br></pre></td></tr></table></figure><br><br>cat函数是另外一种可以替代print的显示方式。它可以将多个对象连接并以连续的方式显示：<br><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat(<span class="string">"The zero occurs at"</span>, <span class="number">2</span>*<span class="constant">pi</span>, <span class="string">"radians."</span>, <span class="string">"\n"</span>)</span><br><span class="line">The <span class="constant">zero</span> occurs <span class="keyword">at</span> <span class="number">6.283185</span> radians.</span><br></pre></td></tr></table></figure><br><br><code>注意</code>，cat函数默认在两个对象间加上空格。如果需要换行，则可以使用换行符（\n）来结束本行语句。<br><br>cat函数也能显示简单向量：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; cat(<span class="string">"The first few Fibonacci numbers are:"</span>, fib, <span class="string">"...\n"</span>)</span><br><span class="line">The first few Fibonacci numbers are: <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> ...</span><br></pre></td></tr></table></figure><br><br>cat函数对变量的输出有更多的控制和选择，这在R程序中尤为重要。但它也有缺陷，即cat函数无法显示复合的数据结构，如矩阵和列表。用cat函数显示列表会得到以下结果：<br><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">cat</span>(<span class="keyword">list</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>))</span><br><span class="line"><span class="keyword">Error</span> <span class="keyword">in</span> <span class="keyword">cat</span>(<span class="keyword">list</span>(...), <span class="keyword">file</span>, sep, fill, labels, <span class="keyword">append</span>) :</span><br><span class="line">argument 1 (<span class="keyword">type</span> <span class="keyword">list</span>) cannot be handled <span class="keyword">by</span> <span class="keyword">cat</span></span><br></pre></td></tr></table></figure><br><br><div class="note unreleased"><br>  <h5>设定变量</h5><br>  <p>问题:如何将某个值赋值给一个变量。</p><br></div><br>### 解决方案<br><br>使用赋值运算符（&lt;-）进行赋值。在赋值前无须对变量进行声明：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure><br><br>## 讨论<br><br>R软件采用“计算器”模式，方便快捷。但是，有时候需要定义变量并保存变量值。这省去了重复输入的时间并使你的工作更为明晰。<br><br>在R软件中，不必对变量进行声明或者显式地创建变量，只需要将值赋予一个名称，R软件就会自动生成该名称的变量：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">3</span></span><br><span class="line">&gt; y &lt;- <span class="number">4</span></span><br><span class="line">&gt; z &lt;- <span class="built_in">sqrt</span>(x^<span class="number">2</span> + y^<span class="number">2</span>)</span><br><span class="line">&gt; print(z)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure><br><br><code>注意</code>，赋值操作由一个小于号（&lt;）和连字符（-）构成，两个符号之间没有空格。<br><br>当使用此种方法定义变量时，该变量将存储到当前的工作空间中。此时工作空间仅存储在计算机的内存中，当退出R软件时可保存至本地硬盘。工作空间会永久保存该变量，直至用户删除或替代该变量。<br><br>R软件是动态的输入语言，即可随意改变变量的数据类型。我们可以先定义x为数值型变量，随后马上对其赋值一个字符串向量，在这一过程中R软件能完全理解用户的意图：<br><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  x &lt;- <span class="number">3</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span><span class="params">(x)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; x &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="string">"fee"</span>, <span class="string">"fie"</span>, <span class="string">"foe"</span>, <span class="string">"fum"</span>)</span></span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span><span class="params">(x)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"fee"</span> <span class="string">"fie"</span> <span class="string">"foe"</span> <span class="string">"fum"</span></span><br></pre></td></tr></table></figure><br><br>在某些R函数中，你会看到很特别的赋值符号&lt;&lt;-：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure><br><br>这一操作能强制赋值给一个全局变量，而不是局部变量。<br><br>为了全面介绍，在此给出另外两种赋值形式。也可以在命令提示符中使用单个等号（=）对变量进行赋值。在所有可以应用向左赋值符号（&lt;-）的地方都可以使用向右赋值符号（-&gt;），它对右侧变量进行赋值：<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; foo = <span class="number">3</span></span><br><span class="line">&gt; print(foo)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; <span class="number">5</span> -&gt; fum</span><br><span class="line">&gt; print(fum)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span></span><br></pre></td></tr></table></figure><br><br><div class="note unreleased"><br><h5>列出所有变量</h5><br><p>问题:<br>你希望知道目前工作空间中存在哪些已定义的变量和函数。<br></p></div>

<h3 id="解决方案">解决方案</h3><p>使用ls函数，或者使用ls.str函数了解每个变量更详细的信息。</p>
<h3 id="讨论">讨论</h3><p>ls函数可以显示当前工作空间中所有对象的名称：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">10</span></span><br><span class="line">&gt; y &lt;- <span class="number">50</span></span><br><span class="line">&gt; z &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="string">"three"</span>, <span class="string">"blind"</span>, <span class="string">"mice"</span>)</span></span></span><br><span class="line">&gt; f &lt;- <span class="function"><span class="title">function</span><span class="params">(n,p)</span></span> <span class="function"><span class="title">sqrt</span><span class="params">(p*(<span class="number">1</span>-p)</span></span>/n)</span><br><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">()</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，ls函数输出的结果是一个字符串向量，其中向量的每个元素代表一个变量名。当工作空间中没有已定义的变量时，函数ls会返回一个空向量，它会产生如下令人迷惑的结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">character</span><span class="params">(<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>事实上，R软件采用这样的方式向用户说明，ls函数返回一个长度为0的字符串向量；即工作空间中不含有任何已定义变量。</p>
<p>如果你除了变量名称以外还想对变量有更多的了解，那么你可以使用ls.str函数，该函数会返回变量的一些其他信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls.str()</span><br><span class="line">f : function (n, p)</span><br><span class="line">x :  num <span class="number">10</span></span><br><span class="line">y :  num <span class="number">50</span></span><br><span class="line">z :  chr [<span class="number">1</span>:<span class="number">3</span>] <span class="string">"three"</span> <span class="string">"blind"</span> <span class="string">"mice"</span></span><br></pre></td></tr></table></figure>
<p>ls.str函数之所以写为ls.str，原因在于其功能既显示了所有变量的名称，又对所有变量使用了str函数，方法12.15对此进行了详细的说明。</p>
<p>ls函数不会显示以点（.）开头的变量名，以点开头的变量一般作为隐藏变量不为用户所知（这一输出规定来源于UNIX系统）。在R软件中，可以通过将ls.str函数中的all.names参数设定为TRUE，强制列出所有变量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class">.hidvar</span> &lt;- <span class="number">10</span></span><br><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">()</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br><span class="line">&gt; <span class="function"><span class="title">ls</span><span class="params">(all.names=TRUE)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">".hidvar"</span> <span class="string">"f"</span>       <span class="string">"x"</span>       <span class="string">"y"</span>       <span class="string">"z"</span></span><br></pre></td></tr></table></figure>
<div class="note unreleased"><br>  <h5>删除变量</h5><br>  <p>问题:你希望删除工作空间中不需要的变量和函数，或者完全删除它们的取值内容。</p><br></div>

<h3 id="解决方案-1">解决方案</h3><p>使用rm函数。</p>
<h3 id="讨论-1">讨论</h3><p>在R软件的使用过程中，工作空间容易很快变得杂乱。rm函数能永久地从工作空间中删除一个或多个对象：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- <span class="number">2</span>*pi</span><br><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">6.283185</span></span><br><span class="line">&gt; <span class="function"><span class="title">rm</span><span class="params">(x)</span></span></span><br><span class="line">&gt; x</span><br><span class="line">Error: <span class="tag">object</span> <span class="string">"x"</span> not found</span><br></pre></td></tr></table></figure>
<p>该命令无法“撤销”，即删除的变量无法找回。</p>
<p>你可以通过如下命令同时删除多个变量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">rm</span><span class="params">(x,y,z)</span></span></span><br></pre></td></tr></table></figure>
<p>你甚至可以同时删除工作空间中所有的内容。rm函数中有一个list参数，它包含所有需要删除的变量名称。前面章节介绍过ls函数能返回所有变量名称，因此你可以通过结合rm函数与ls函数，删除工作空间中的所有变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls()</span><br><span class="line">[<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"x"</span> <span class="string">"y"</span> <span class="string">"z"</span></span><br><span class="line">&gt; rm(list=ls())</span><br><span class="line">&gt; ls()</span><br><span class="line">character(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>R软件的道德规范</code>在与他人共享代码时，绝不能将带有<code>rm(list=ls())</code>的恶意代码通过网络示例或者其他方法发送至他人。用此手段删除对方工作空间中所有的内容是如此粗鄙的行为，让你变得不受欢迎</p>
<div class="note warning"><br>  <h5>生成向量</h5><br>  <p>问题:如何生成一个向量。</p><br></div>

<h3 id="解决方案-2">解决方案</h3><p>通过<code>c(...)</code>命令对给定的值构建一个向量。</p>
<h3 id="讨论-2">讨论</h3><p>向量不仅是R的一种数据结构，它还是贯通R软件的重要组成部分。向量中可以包含数值、字符串或者逻辑值，但不能由多种格式混合组成。</p>
<p>在<code>c(...)</code>命令中添加元素对向量进行赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span></span><br><span class="line">&gt; c(<span class="number">1</span>*pi, <span class="number">2</span>*pi, <span class="number">3</span>*pi, <span class="number">4</span>*pi)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">3.141593</span>  <span class="number">6.283185</span>  <span class="number">9.424778</span> <span class="number">12.566371</span></span><br><span class="line">&gt; c(<span class="string">"Everyone"</span>, <span class="string">"loves"</span>, <span class="string">"stats."</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"Everyone"</span> <span class="string">"loves"</span>    <span class="string">"stats."</span></span><br><span class="line">&gt; c(TRUE,TRUE,FALSE,TRUE)</span><br><span class="line">[<span class="number">1</span>]  TRUE  TRUE FALSE  TRUE</span><br></pre></td></tr></table></figure>
<p>如果c(…) 中的参数自身是向量，那么c(…) 命令会将多个向量合为一个向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1 &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt; v2 &lt;- c(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">&gt; c(v1,v2)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>对于一个向量来说，其中的内容不能由多种数据格式混合组成，如在一个向量中同时包含数值和字符串。R软件对于混合型向量会进行如下的格式转换：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1 &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span></span><br><span class="line">&gt; v3 &lt;- <span class="function"><span class="title">c</span><span class="params">(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>)</span></span></span><br><span class="line">&gt; <span class="function"><span class="title">c</span><span class="params">(v1,v3)</span></span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"1"</span> <span class="string">"2"</span> <span class="string">"3"</span> <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span></span><br></pre></td></tr></table></figure>
<p>这里，用户希望将一组数值数据和一组字符串数据同时赋值给一个新的向量。对于这种情况，R软件会先将数值数据转换为字符串数据，使得两组数据的类型得以统一。</p>
<p>理论上来说，两组数据能同时赋值于一个向量的条件，在于两组数据具有相同的类型 （mode）。例如3.1415和”foo”分别为数值型和字符型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; mode(<span class="number">3.1415</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br><span class="line">&gt; mode(<span class="string">"foo"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"character"</span></span><br></pre></td></tr></table></figure>
<p>上述两者的类型不同。为了生成新的向量，R软件将3.1415转换为字符类型，使得3.1415的类型与”foo”的类型一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; c(<span class="number">3.1415</span>, <span class="string">"foo"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"3.1415"</span> <span class="string">"foo"</span></span><br><span class="line">&gt; mode(c(<span class="number">3.1415</span>, <span class="string">"foo"</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="string">"character"</span></span><br></pre></td></tr></table></figure>
<p><code>警告</code>：c是一个通用的运算符，这意味着它不仅应用于向量，同时也应用于其他的数据类型。但是，它可能不是那么精确地与用户预期相一致。因此在将c命令用于其他数据类型和对象前，要查看它的效果。</p>
<div class="note warning"><br>  <h5>计算基本统计量</h5><br>  <p>问题:如何使用R软件计算下列统计量：均值、中位数、标准差、方差、协方差和相关系数。</p><br></div>

<h3 id="解决方案-3">解决方案</h3><p>采用如下函数进行计算，其中x、y均为向量：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mean</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">median</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">sd</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">var</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(x, y)</span></span></span><br><span class="line"><span class="function"><span class="title">cov</span><span class="params">(x, y)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="讨论-3">讨论</h3><p>我初次阅读R软件帮助文件是为了寻找“标准差的计算过程”这一内容，原本认为帮助文件会以一整章篇幅介绍这一重要概念。</p>
<p>实际上没有那么复杂。</p>
<p>R软件中，用简单的函数便能完成标准差和其他基本统计量的计算。一般来说，函数参数是一个数值向量，而函数返回计算出的统计量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; mean(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.8</span></span><br><span class="line">&gt; median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">&gt; sd(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">11.03328</span></span><br><span class="line">&gt; var(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">121.7333</span></span><br></pre></td></tr></table></figure>
<p>其中sd函数计算样本标准差，var函数计算样本方差。</p>
<p>cor函数以及cov函数分别计算两变量间的相关系数与协方差：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; y &lt;- log(x+<span class="number">1</span>)</span><br><span class="line">&gt; cor(x,y)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9068053</span></span><br><span class="line">&gt; cov(x,y)</span><br><span class="line">[<span class="number">1</span>] <span class="number">11.49988</span></span><br></pre></td></tr></table></figure>
<p>上述函数对于是否存在缺失值（NA）很敏感。某个变量中的一个缺失值就有可能导致函数返回NA结果，甚至可能造成计算机在计算过程中报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,NA)</span><br><span class="line">&gt; mean(x)</span><br><span class="line">[<span class="number">1</span>] NA</span><br><span class="line">&gt; sd(x)</span><br><span class="line">[<span class="number">1</span>] NA</span><br></pre></td></tr></table></figure>
<p>虽然R软件对于缺失值的敏感程度有时会造成用户的不便，但这种处理方式也是合情合理的。对于R软件返回的结果你应该慎重地考虑：数据中的缺失值是否会严重影响统计结果？如果是，那么R软件返回错误结果是正确的；如果不是，则可以通过设置参数na.rm=TRUE, 告知R软件忽略缺失值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; x &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,NA)</span><br><span class="line">&gt; mean(x, na.rm=TRUE)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.4</span></span><br><span class="line">&gt; sd(x, na.rm=TRUE)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.140175</span></span><br></pre></td></tr></table></figure>
<p>mean函数和sd函数能巧妙地处理数据框数据，自动将数据框中的每一列认为是不同的变量，并对每列数据分别进行计算。下面的例子展示了mean和sd函数对有三列的数据框的计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(dframe)</span><br><span class="line">       small    mediumbig</span><br><span class="line"><span class="number">1</span>  <span class="number">0.6739635</span>  <span class="number">10.526448</span>   <span class="number">99.83624</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.5524619</span>   <span class="number">9.205156</span>  <span class="number">100.70852</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.3250562</span>  <span class="number">11.427756</span>   <span class="number">99.73202</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.2143595</span>   <span class="number">8.533180</span>   <span class="number">98.53608</span></span><br><span class="line"><span class="number">5</span>  <span class="number">1.3107692</span>   <span class="number">9.763317</span>  <span class="number">100.74444</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2.1739663</span>   <span class="number">9.806662</span>   <span class="number">98.58961</span></span><br><span class="line"><span class="number">7</span>  <span class="number">1.6187899</span>   <span class="number">9.150245</span>  <span class="number">100.46707</span></span><br><span class="line"><span class="number">8</span>  <span class="number">0.8872657</span>  <span class="number">10.058465</span>   <span class="number">99.88068</span></span><br><span class="line"><span class="number">9</span>  <span class="number">1.9170283</span>   <span class="number">9.182330</span>  <span class="number">100.46724</span></span><br><span class="line"><span class="number">10</span> <span class="number">0.7767406</span>   <span class="number">7.949692</span>  <span class="number">100.49814</span></span><br><span class="line">&gt; mean(dframe)</span><br><span class="line">   small    medium       big</span><br><span class="line"><span class="number">1.245040</span>  <span class="number">9.560325</span> <span class="number">99.946003</span></span><br><span class="line">&gt; sd(dframe)</span><br><span class="line">    small    medium       big</span><br><span class="line"><span class="number">0.5844025</span> <span class="number">0.9920281</span> <span class="number">0.8135498</span></span><br></pre></td></tr></table></figure>
<p>注意，mean和sd函数都会返回3个值，每个数值对应着对数据框中一列数据的计算结果（一般地，R软件会以一个包含三个元素的向量返回结果，其中每个元素的names属性由数据框中各个列的名称得来）。</p>
<p>var函数也能处理数据框数据，但处理方式与mean函数和sd函数有些许不同。var函数计算每两列变量间的协方差，并以协方差矩阵的形式返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; var(dframe)</span><br><span class="line">             small      medium         big</span><br><span class="line">small   <span class="number">0.34152627</span> -<span class="number">0.21516416</span> -<span class="number">0.04005275</span></span><br><span class="line">medium -<span class="number">0.21516416</span>  <span class="number">0.98411974</span> -<span class="number">0.09253855</span></span><br><span class="line">big    -<span class="number">0.04005275</span> -<span class="number">0.09253855</span>  <span class="number">0.66186326</span></span><br></pre></td></tr></table></figure>
<p>同样，如果x是一个数据框或矩阵，则<code>cor(x)</code> 返回其相关系数矩阵；而<code>cov(x)</code> 返回其协方差矩阵：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; cor(dframe)</span><br><span class="line">             small     medium         big</span><br><span class="line">small   <span class="number">1.00000000</span> -<span class="number">0.3711367</span> -<span class="number">0.08424345</span></span><br><span class="line">medium -<span class="number">0.37113670</span>  <span class="number">1.0000000</span> -<span class="number">0.11466070</span></span><br><span class="line">big    -<span class="number">0.08424345</span> -<span class="number">0.1146607</span>  <span class="number">1.00000000</span></span><br><span class="line">&gt; cov(dframe)</span><br><span class="line">             small      medium         big</span><br><span class="line">small   <span class="number">0.34152627</span> -<span class="number">0.21516416</span> -<span class="number">0.04005275</span></span><br><span class="line">medium -<span class="number">0.21516416</span>  <span class="number">0.98411974</span> -<span class="number">0.09253855</span></span><br><span class="line">big    -<span class="number">0.04005275</span> -<span class="number">0.09253855</span>  <span class="number">0.66186326</span></span><br></pre></td></tr></table></figure>
<p><code>median</code>函数无法辨认数据框形式的数据。若需计算数据框数据的中位数，需要使用方法6.4对各列分别进行计算。</p>
<div class="note info"><br>  <h5>生成数列</h5><br>  <p>问题:如何生成一个数列。</p><br></div>

<h3 id="解决方案-4">解决方案</h3><p>使用表达式<code>n:m</code>生成简单数列n,n+1,n+2,…,m：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>对于增量不为1的数列，可以使用<code>seq</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">1</span>, to=<span class="number">5</span>, by=<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>使用rep函数生成由一个数的重复所组成的数列：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(<span class="number">1</span>, times=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="讨论-4">讨论</h3><p>冒号运算符<code>（n:m）</code>会生成包含n,n+1,n+2,…,m的一个向量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span>:<span class="number">9</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">&gt; <span class="number">10</span>:<span class="number">19</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span></span><br><span class="line">&gt; <span class="number">9</span>:<span class="number">0</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，上述最后一个表达式（9:0），R软件能自动识别9大于0并以递减的形式生成数列。</p>
<p>冒号运算符仅能生成增量为1的数列。而seq函数通过它的第三个参数来规定数列元素的增量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>, by=<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>, by=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>相应地，你可以在函数中规定输出数列的长度，R软件会自动识别并根据要求生成等增量数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">20</span>, length.out=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span></span><br><span class="line">&gt; seq(from=<span class="number">0</span>, to=<span class="number">100</span>, length.out=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]   <span class="number">0</span>  <span class="number">25</span>  <span class="number">50</span>  <span class="number">75</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>函数seq的增量参数并非一定是整数。R软件也可以生成具有分数增量的数列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(from=<span class="number">1.0</span>, to=<span class="number">2.0</span>, length.out=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.00</span> <span class="number">1.25</span> <span class="number">1.50</span> <span class="number">1.75</span> <span class="number">2.00</span></span><br></pre></td></tr></table></figure>
<p>特殊情况下，若需要生成重复某个值的数列，则可以使用rep函数，生成的数列重复其第一个参数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(pi, times=<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.141593</span> <span class="number">3.141593</span> <span class="number">3.141593</span> <span class="number">3.141593</span> <span class="number">3.141593</span></span><br></pre></td></tr></table></figure>
<div class="note info"><br>  <h5>向量比较</h5><br>  <p>问题:如何比较两个向量，或者将一个向量的所有元素与某一个常数进行比较。</p><br></div>

<h3 id="解决方案-5">解决方案</h3><p>比较运算符（==、!=、&lt;、&gt;、&lt;=、&gt;=）能对两向量间的各个元素进行比较。这些运算符也能将向量中所有元素与一个常数进行比较。返回结果是每两个元素间比较结果的逻辑值向量。</p>
<h3 id="讨论-5">讨论</h3><p>R软件包含两个逻辑值，TRUE和FALSE。在其他编程语言中也称为布尔值（Boolean values）。</p>
<p>比较运算符通过比较两个值，并根据比较结果返回TRUE或FALSE：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; a &lt;- 3</span><br><span class="line">&gt; a == pi     # 检验两者是否相等</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; a != pi     # 检验两者是否不等</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; a &lt; pi</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; a &gt; pi</span><br><span class="line">[1] FALSE</span><br><span class="line">&gt; a &lt;= pi</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; a &gt;= pi</span><br><span class="line">[1] FALSE</span><br></pre></td></tr></table></figure>
<p>你可以使用R软件一次性地对两个向量进行比较，它会将两个向量中每两个对应的元素进行比较，并以逻辑值向量方式返回比较结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c( 3, pi,  4)</span><br><span class="line">&gt; w &lt;- c(pi, pi, pi)</span><br><span class="line">&gt; v == w# 比较两个各自包含3个元素的向量</span><br><span class="line">[1] FALSE  TRUE FALSE# 结果以包含3个逻辑值的向量形式输出</span><br><span class="line">&gt; v != w</span><br><span class="line">[1]  TRUE FALSE  TRUE</span><br><span class="line">&gt; v &lt; w</span><br><span class="line">[1]  TRUE FALSE FALSE</span><br><span class="line">&gt; v &lt;= w</span><br><span class="line">[1]  TRUE  TRUE FALSE</span><br><span class="line">&gt; v &gt; w</span><br><span class="line">[1] FALSE FALSE  TRUE</span><br><span class="line">&gt; v &gt;= w</span><br><span class="line">[1] FALSE  TRUE  TRUE</span><br></pre></td></tr></table></figure>
<p>也可以将一个向量与一个常数进行比较，R软件会将常数扩充为一组长度与所比较向量的长度相等，并由常数值重复组成的向量，再将新向量与它需要比较向量的对应元素进行比较。所以，之前的例子可以简化为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(3, pi, 4)</span><br><span class="line">&gt; v == pi# 将包含3个元素的向量与一个常数进行比较</span><br><span class="line">[1] FALSE  TRUE FALSE</span><br><span class="line">&gt; v != pi</span><br><span class="line">[1]  TRUE FALSE  TRUE</span><br></pre></td></tr></table></figure>
<p>比较两个向量后，你通常会想知道比较结果中是否存在TRUE，或者比较结果是否全为TRUE。可以应用函数any和all来检验上述问题。两个函数都针对逻辑型变量进行检验，其中如果元素中含有至少一个TRUE，则any函数返回TRUE；如果元素全为TRUE，则all函数返回TRUE：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(3, pi, 4)</span><br><span class="line">&gt; any(v == pi)# 若v向量中元素至少一个等于pi，则返回TRUE</span><br><span class="line">[1] TRUE</span><br><span class="line">&gt; all(v == 0)# 若v向量中所有元素都为0，则返回TRUE</span><br><span class="line">[1] FALSE</span><br></pre></td></tr></table></figure>
<div class="note info"><br>  <h5>选取向量中的元素</h5><br>  <p>问题:如何选取向量中一个或多个元素。</p><br></div>

<h3 id="解决方案-6">解决方案</h3><ul>
<li><p>选择适合问题的索引技术：</p>
</li>
<li><p>根据元素在向量中的位置使用方括号来选出元素，如v[3]代表了v向量中的第三个元素。</p>
</li>
<li><p>索引前加负号（－），排除向量中相应位置的元素。</p>
</li>
<li><p>使用向量索引来选择多个元素值。</p>
</li>
<li><p>使用逻辑向量根据条件来选择元素。</p>
</li>
<li><p>使用名称来选择命名的元素。</p>
</li>
</ul>
<h3 id="讨论-6">讨论</h3><p>从向量中选出某些元素是R的又一项强大功能。和其他编程语言一样，R选取向量元素的基本方法是使用一对方括号和简单索引（下标）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib &lt;- c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>)</span><br><span class="line">&gt; fib</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span></span><br><span class="line">&gt; fib[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br><span class="line">&gt; fib[<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; fib[<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br><span class="line">&gt; fib[<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br><span class="line">&gt; fib[<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>，向量第一个元素的索引（或下标）为1，而非某些编程语言中的0。</p>
<p>另外也可以同时选择一个向量中的多个元素，向量的索引本身可以是一个向量，并且根据下标向量中所指定的位置选择原向量中的元素：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[1:3]# 选择下标为1至3的元素</span><br><span class="line">[1] 0 1 1</span><br><span class="line">&gt; fib[4:9]# 选择下标为4至9的元素</span><br><span class="line">[1]  2  3  5  8 13 21</span><br></pre></td></tr></table></figure></p>
<p>1:3这样的下标意味着选择第1、2、3个元素，如上例所示。索引向量可以不是简单数列，可以选择向量数据中的任何元素，如下例所示，它选择第1、2、4和第8个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>R将负索引看做是排除向量中相应索引的元素。如下标为－1，意味着选择除了向量的第一个元素外的所有其他元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[-1]          # 忽略第一个元素</span><br><span class="line">[1]  1  1  2  3  5  8 13 21 34</span><br></pre></td></tr></table></figure>
<p>通过使用负索引的索引向量，该方法可以扩展为排除多个元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib[1:3]         # 前述向量</span><br><span class="line">[1] 0 1 1</span><br><span class="line">&gt; fib[-(1:3)]      # 在索引前添加负号，排除相应的元素</span><br><span class="line">[1]  2  3  5  8 13 21 34</span><br></pre></td></tr></table></figure>
<p>还可以使用逻辑向量从数据向量中选择元素。与索引逻辑向量取值为TRUE的元素相对应的原始数据向量的元素将被选择：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; fib &lt; 10# 仅当向量中元素值小于10时该表达式为TRUE</span><br><span class="line">[1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE</span><br><span class="line">&gt; fib[fib &lt; 10]# 使用该表达式选择向量中小于10的值</span><br><span class="line">[1] 0 1 1 2 3 5 8</span><br><span class="line">&gt; fib %% 2 == 0# 仅当向量fib中元素值为偶数时该表达式为TRUE</span><br><span class="line">[1]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE</span><br><span class="line">&gt; fib[fib %% 2 == 0]# 使用该表达式选择向量中的偶数值</span><br><span class="line">[1]  0  2  8  34</span><br></pre></td></tr></table></figure>
<p>一般地，索引逻辑向量的长度应与原始数据向量的长度相同，这样才能清晰地选择或者排除每一个元素（若两者长度不同，则需要了解循环规则，具体请参见方法5.3）。</p>
<p>结合向量比较、逻辑运算符以及向量索引，可以用少量的R命令来完成强大的选择功能：</p>
<p>选择所有小于中位数的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ v &gt; median(v) ]</span><br></pre></td></tr></table></figure></p>
<p>选择分布于两端5%的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ (v &lt; quantile(v,<span class="number">0.05</span>)) | (v &gt; quantile(v,<span class="number">0.95</span>)) ]</span><br></pre></td></tr></table></figure></p>
<p>选择所有处于均值的两倍标准差区间以外的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ abs(v-mean(v)) &gt; <span class="number">2</span>*sd(v) ]</span><br></pre></td></tr></table></figure></p>
<p>选择所有NA或NULL值的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[ !is.na(v) &amp; !is.<span class="keyword">null</span>(v) ]</span><br></pre></td></tr></table></figure></p>
<p>最后一个索引特征可以让你通过名称选择元素。它要求数据向量有name属性，即其中每个元素都定义各自的名称。可以指定一个字符串向量来完成该数据向量名称的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; years &lt;- c(<span class="number">1960</span>, <span class="number">1964</span>, <span class="number">1976</span>, <span class="number">1994</span>)</span><br><span class="line">&gt; names(years) &lt;- c(<span class="string">"Kennedy"</span>, <span class="string">"Johnson"</span>, <span class="string">"Carter"</span>, <span class="string">"Clinton"</span>)</span><br><span class="line">&gt; years</span><br><span class="line">Kennedy Johnson  Carter Clinton</span><br><span class="line">   <span class="number">1960</span>    <span class="number">1964</span>    <span class="number">1976</span>    <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<p>一旦元素的名称已定义，则可以使用名称引用向量中的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; years[<span class="string">"Carter"</span>]</span><br><span class="line">Carter</span><br><span class="line">  <span class="number">1976</span></span><br><span class="line">&gt; years[<span class="string">"Clinton"</span>]</span><br><span class="line">Clinton</span><br><span class="line">   <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<p>可以推广到使用名称来索引向量元素：R软件会返回向量中对应名称的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; years[c(<span class="string">"Carter"</span>,<span class="string">"Clinton"</span>)]</span><br><span class="line">Carter Clinton</span><br><span class="line">  <span class="number">1976</span>    <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<div class="note info"><br>  <h5>向量的计算</h5><br>  <p>问题:你希望对整个向量执行计算。</p><br></div><br>### 解决方案<br><br>基本的数学运算符可以对向量中的元素进行逐个计算。许多其他的函数也能对向量元素逐个进行运算，并以向量的形式输出结果。<br><br>### 讨论<br><br>向量计算是R软件的一大特色。所有的基本数学运算符都能应用于向量对中。这些运算符对两个向量中相应的每个元素对进行计算，即将两个向量中对应的元素进行基本运算：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; v &lt;- c(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>)</span><br><span class="line">&gt; w &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&gt; v + w</span><br><span class="line">[<span class="number">1</span>] <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br><span class="line">&gt; v - w</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line">&gt; v * w</span><br><span class="line">[<span class="number">1</span>] <span class="number">11</span> <span class="number">24</span> <span class="number">39</span> <span class="number">56</span> <span class="number">75</span></span><br><span class="line">&gt; v / w</span><br><span class="line">[<span class="number">1</span>] <span class="number">11.000000</span>  <span class="number">6.000000</span>  <span class="number">4.333333</span>  <span class="number">3.500000</span>  <span class="number">3.000000</span></span><br><span class="line">&gt; w ^ v</span><br><span class="line">[<span class="number">1</span>]     <span class="number">1</span>   <span class="number">4096</span>   <span class="number">1594323</span>   <span class="number">268435456</span>  <span class="number">30517578125</span></span><br></pre></td></tr></table></figure><br><br><code>注意</code>，输出的结果向量的长度与原向量的长度相等。原因是结果向量中的每个元素都是由原向量对中对应的两个元素计算得来。<br><br>若使一个向量与一个常数进行运算，则会将该向量的每个元素与常数进行运算：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; w + <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">&gt; w - <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">&gt; w * <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span></span><br><span class="line">&gt; w / <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.5</span> <span class="number">1.0</span> <span class="number">1.5</span> <span class="number">2.0</span> <span class="number">2.5</span></span><br><span class="line">&gt; w ^ <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">4</span>  <span class="number">9</span> <span class="number">16</span> <span class="number">25</span></span><br><span class="line">&gt; <span class="number">2</span> ^ w</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">8</span> <span class="number">16</span> <span class="number">32</span></span><br></pre></td></tr></table></figure><br><br>例如，可以在一个表达式中得到一个向量减去其元素均值后的向量：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; mean(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; w - mean(w)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">2</span> -<span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br></pre></td></tr></table></figure><br><br>同样，可以通过计算向量减去其均值并除以其标准差，来获得该向量数据的z分数（z-score）：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; sd(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.581139</span></span><br><span class="line">&gt; (w - mean(w)) / sd(w)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">1.2649111</span> -<span class="number">0.6324555</span>  <span class="number">0.0000000</span>  <span class="number">0.6324555</span>  <span class="number">1.2649111</span></span><br></pre></td></tr></table></figure><br><br>向量的运算功能远不止对元素的简单运算。还有许多函数对整个向量进行运算。如sqrt函数和log函数，都可以应用于整个向量中的每个元素，并以向量的形式输出结果：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; w</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; sqrt(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.000000</span> <span class="number">1.414214</span> <span class="number">1.732051</span> <span class="number">2.000000</span> <span class="number">2.236068</span></span><br><span class="line">&gt; log(w)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.0000000</span> <span class="number">0.6931472</span> <span class="number">1.0986123</span> <span class="number">1.3862944</span> <span class="number">1.6094379</span></span><br><span class="line">&gt; sin(w)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0.8414710</span>  <span class="number">0.9092974</span>  <span class="number">0.1411200</span> -<span class="number">0.7568025</span> -<span class="number">0.9589243</span></span><br></pre></td></tr></table></figure><br><br>R软件的向量运算有两大优点。第一个最明显的优点是操作的简便性，其他编程软件中需要通过循环才能完成的操作，在R软件中一行命令便可以实现。第二个优点是计算速度快。大多数向量化的运算直接由C语言代码来实现，它比你自己用R写的代码本质上快很多。<br><div class="note"><br>    <h5>运算符优先级问题</h5><br>    <p>问题:R软件输出结果有误，你希望了解问题是否由运算符的优先级所导致的。</p><br></div>

<h3 id="解决方案-7">解决方案</h3><p>所有的运算符显示在表2-1中，并以最高优先级至最低优先级的顺序排列。相同优先级的运算符，除特指外皆由从左至右的顺序进行运算。</p>
<p>表2-1：运算符优先级</p>
<p>运算符含义参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ [[               索引方法<span class="number">2.9</span></span><br><span class="line">:: :::             使用名称访问变量</span><br><span class="line">$ @                元素提取、位置提取</span><br><span class="line">^                  指数形式（从右到左）</span><br><span class="line">- +                元素的负、正</span><br><span class="line">:                  创建数列方法<span class="number">2.7</span>，<span class="number">7.14</span></span><br><span class="line">%any%              特殊运算符讨论</span><br><span class="line">* /                乘、除讨论</span><br><span class="line">+ -                加、减</span><br><span class="line">== !=  &lt; &gt; &lt;= &gt;=   比较运算符方法<span class="number">2.8</span></span><br><span class="line">！                 逻辑取反</span><br><span class="line">&amp;  &amp;&amp;              逻辑“与”、 短路“与”</span><br></pre></td></tr></table></figure>
<p>表2-1：运算符优先级（续）<br>运算符含义参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  ||   逻辑 “或”、 短路“或”</span><br><span class="line">~       公式方法<span class="number">11.1</span></span><br><span class="line">-&gt;  -&gt;&gt; 向右赋值方法<span class="number">2.2</span></span><br><span class="line">=       赋值（从右向左）方法<span class="number">2.2</span></span><br><span class="line">&lt;-  &lt;&lt;- 赋值（从右向左）方法<span class="number">2.2</span></span><br></pre></td></tr></table></figure>
<h3 id="讨论-7">讨论</h3><p>用户在R中搞错运算符的优先级是经常遇到的问题。我经常会犯这样的错误，例如我会不假思索地认为表达式0:n－1会生成从0~n－1的数列，但事实并非如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; n &lt;-<span class="number">10</span></span><br><span class="line">&gt; <span class="number">0</span>:n-<span class="number">1</span></span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>该表达式生成－1~n－1的数列，因为R软件将上式理解为(0:n)－1。</p>
<p>你可能不熟悉表2-1中的符号%any%，R中用两个百分号夹带一个符号的形式（%…%）表示一个二元运算符。R中预定义的二元运算符的含义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%   取模</span><br><span class="line">%/%  整除</span><br><span class="line">%*%  矩阵乘积</span><br><span class="line">%in% 右侧变量中包含左侧变量时，为TRUE；否则，为FALSE。</span><br></pre></td></tr></table></figure>
<p>你可以通过%…%记号来定义新的二元运算符，参见方法12.19。此种运算符都具有相同的运算优先级。</p>
<div class="note unreleased"><br>  <h5>定义函数</h5><br>  <p>问题：如何定义一个R函数。</p><br></div>

<h3 id="解决方案-8">解决方案</h3><p>使用关键字function，并在其后跟随函数参数列表和函数主体。其基本形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(param1, ...., paramN) expr</span><br></pre></td></tr></table></figure>
<p>函数主体可以是一系列表达式，这些表达式需要用大括号括起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(param1, ..., paramN) &#123;</span><br><span class="line">  expr1</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">  exprM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="讨论-8">讨论</h3><p>函数的定义告诉R软件“用何种方式进行计算”。例如，R软件没有内置计算变异系数的函数，因此你可以定义函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cv &lt;- function(x) sd(x)/mean(x)</span><br><span class="line">&gt; cv(<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.5504819</span></span><br></pre></td></tr></table></figure>
<p>第一行定义了名为cv的函数，第二行引用该函数，以1∶10作为其参数x的值。函数对参数应用函数主体中的表达式sd(x)/mean(x)进行计算并返回结果。</p>
<p>定义函数后，我们可以在任何需要函数的地方应用它，例如可以作为lapply函数的第二个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cv &lt;- function(x) sd(x)/mean(x)</span><br><span class="line">&gt; lapply(lst, cv)</span><br></pre></td></tr></table></figure>
<p>函数主体如果包含多行表达式，则需要使用大括号来确定函数内容的起始和结束位置。下面这一函数采用了欧几里德算法计算两个整数的最大公约数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcd &lt;- function(a,b) &#123;</span><br><span class="line">+ <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span>(a)</span><br><span class="line">+ <span class="keyword">else</span> <span class="keyword">return</span>(gcd(b, a %% b))</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>
<p>R软件也允许使用匿名函数，匿名函数是没有函数名称但在单行的语句中很实用的函数。先前的例子中我们提到将cv函数作为lapply函数的一个参数，而若使用匿名函数直接作为lapply函数的参数，则能将原先的命令简化至同一行中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; lapply(lst, function(x) sd(x)/mean(x))</span><br></pre></td></tr></table></figure>
<p>由于本书重点不在于介绍R的编程语言，这里不对R函数编程的细微之处进行解释。下面给出几个需要注意的地方：</p>
<p><code>返回值</code></p>
<p>所有函数都有一个返回值，即函数主体最后一个表达式值。你也可以通过return(expr)命令给出函数的返回值。</p>
<p><code>值调用</code></p>
<p>函数参数是“值调用”——如果你改变了函数中的参数值，改变只是局部的，并不会影响该参数所引用的变量值。</p>
<p><code>局部变量</code></p>
<p>你可以简单地通过赋值来创建一个局部变量，函数结束后该局部变量会消失。</p>
<p><code>条件执行</code></p>
<p>R语法中包含if语句，更多详情可以使用help(Control)命令查看。</p>
<p><code>循环语句</code></p>
<p>R语法中也包括for循环、while循环以及repeat循环语句。更多详情可以使用help(Control)命令查看。</p>
<p><code>全局变量</code></p>
<p> 在函数中，你可以通过&lt;&lt;-操作符来改变全局变量的值，但此种方法不推荐使用。</p>
<p><code>另请参阅</code> 有关如何定义函数，参见《An Introduction to R》（<a href="http://cran.r-project.org/doc/manuals/R-intro.pdf）和《R" target="_blank" rel="external">http://cran.r-project.org/doc/manuals/R-intro.pdf）和《R</a> in a Nutshell》。2.12 定义函数</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。</p>
<p>R语言是在大数据时代被工业界了解和认识的语言，R语言被时代赋予了，挖掘数据价值，发现数据规律，创造数据财富的任务。</p>
<p>R语言也是帮助人们发挥智慧和创造力的最好的生产工具，我们不仅要学好R语言，还要用好R语言，为社会注入更多的创新的生产力。</p>
<p><img src="http://www.idatacamp.com/wordpress/wp-content/uploads/2015/09/14210N40130-194U.jpg"/></p>
<p>我认为“R是最值得学习的编程语言”。不论你还在读书，还是已经工作，掌握R语言这个工具，找最适合自己的位置，前途将无限量。</p>
<p>本文主要记录了笔者自学R的基础知识点，这里直介绍R的基础入门知识，全文使用RStudio操作</p>]]>
    
    </summary>
    
      <category term="r" scheme="http://yoursite.com/tags/r/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[辨析 Sass 中的 Map 和 List]]></title>
    <link href="http://yoursite.com/2015/10/21/map-and-list-in-sass/"/>
    <id>http://yoursite.com/2015/10/21/map-and-list-in-sass/</id>
    <published>2015-10-21T02:34:12.000Z</published>
    <updated>2015-11-07T16:06:08.000Z</updated>
    <content type="html"><![CDATA[<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p>
<p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p>
<p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p>
<a id="more"></a>
<p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p>
<h2 id="测试表格">测试表格</h2><table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>site</code></td>
<td>Sitewide information.</td>
</tr>
<tr>
<td><code>page</code></td>
<td>Page specific information and custom variables set in front-matter.</td>
</tr>
<tr>
<td><code>config</code></td>
<td>Site configuration</td>
</tr>
<tr>
<td><code>theme</code></td>
<td>Theme configuration. Inherits from site configuration.</td>
</tr>
<tr>
<td><code>_</code> (single underscore)</td>
<td><a href="http://lodash.com/" target="_blank" rel="external">Lodash</a> library</td>
</tr>
<tr>
<td><code>path</code></td>
<td>Path of current page</td>
</tr>
<tr>
<td><code>url</code></td>
<td>Full URL of current page</td>
</tr>
<tr>
<td><code>env</code></td>
<td>Environment variables</td>
</tr>
</tbody>
</table>
<h2 id="语法比较">语法比较</h2><div class="note"><br>    <h5>测试标题</h5><br>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 <code>min-width</code>、<code>max-width</code>、<code>font-size</code> 和 <code>line-height</code> 四个样式。</p><br></div>

<h4 id="Map_语法">Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-map: (&#10;&#160; &#160; small: (&#10;&#160; &#160; &#160; &#160; min-width: null,&#10;&#160; &#160; &#160; &#160; max-width: 479px,&#10;&#160; &#160; &#160; &#160; base-font: 16px,&#10;&#160; &#160; &#160; &#160; vertical-rhythm: 1.3&#10;&#160; &#160; ),&#10;&#160; &#160; medium: (&#10;&#160; &#160; &#160; &#160; min-width: 480px,&#10;&#160; &#160; &#160; &#160; max-width: 959px,&#10;&#160; &#160; &#160; &#160; base-font: 18px,&#10;&#160; &#160; &#160; &#160; vertical-rhythm: 1.414&#10;&#160; &#160; ),&#10;&#160; &#160; large: (&#10;&#160; &#160; &#160; &#160; min-width: 960px,&#10;&#160; &#160; &#160; &#160; max-width: 1099px,&#10;&#160; &#160; &#160; &#160; base-font: 18px,&#10;&#160; &#160; &#160; &#160; vertical-rhythm: 1.5&#10;&#160; &#160; ),&#10;&#160; &#160; xlarge: (&#10;&#160; &#160; &#160; &#160; min-width: 1100px,&#10;&#160; &#160; &#160; &#160; max-width: null,&#10;&#160; &#160; &#160; &#160; base-font: 21px,&#10;&#160; &#160; &#160; &#160; vertical-rhythm: 1.618&#10;&#160; &#160; )&#10;);</span><br></pre></td></tr></table></figure>
<h4 id="多重列表语法">多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (&#10;&#160; &#160; (small, null, 479px, 16px, 1.3),&#10;&#160; &#160; (medium, 480px, 959px, 18px, 1.414),&#10;&#160; &#160; (large, 960px, 1099px, 18px, 1.5),&#10;&#160; &#160; (xlarge, 1100px, null, 21px, 1.618)&#10;);</span><br></pre></td></tr></table></figure>
<h2 id="遍历比较">遍历比较</h2><div class="note info"><br>    <h5>测试标题</h5><br>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p><br></div>

<h4 id="遍历_Map">遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p>
<p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;&#10;&#160; &#160; $min-width: map-get($map, min-width);&#10;&#160; &#160; $max-width: map-get($map, max-width);&#10;&#160; &#160; $base-font: map-get($map, base-font);&#10;&#160; &#160; $vertical-rhythm: map-get($map, vertical-rhythm);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历多重列表">遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p>
<p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="慎用多重列表">慎用多重列表</h2><div class="note warning"><br>    <h5>测试标题</h5><br>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p><br></div>

<h4 id="遗漏键值">遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (&#10;&#160; &#160; (small, null, 479px, 16px, 1.3),&#10;&#160; &#160; (medium, 480px, 959px, 18px, 1.414),&#10;&#160; &#160; (large, 960px, 1099px, 18px, 1.5),&#10;&#160; &#160; (xlarge, 1100px, 21px, 1.618)&#10;);&#10;&#10;p &#123;&#10;&#160; &#160; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#10;&#160; &#160; &#160; &#160; @if $min-width &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; @include breakpoint( $min-width ) &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; font-size: $base-font;&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; line-height: $vertical-rhythm;&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#125;&#10;&#160; &#160; &#160; &#160; &#125; @else &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; font-size: $base-font;&#10;&#160; &#160; &#160; &#160; &#160; &#160; line-height: $vertical-rhythm;&#10;&#160; &#160; &#160; &#160; &#125;&#10;&#160; &#160; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p>
<p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p>
<h4 id="查找特定列表">查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure>
<p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@function get-list($label) &#123;&#10;&#160; &#160; @each $list in $breakpoint-list &#123;&#10;&#160; &#160; &#160; &#160; @if nth($list, 1) == $label &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; @return $list;&#10;&#160; &#160; &#160; &#160; &#125;&#10;&#160; &#160; &#125;&#10;&#160; &#160; @return null;&#10;&#125;&#10;$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p>
<h4 id="缺少原生的_Map_函数">缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p>
<p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p>
<h2 id="总结">总结</h2><div class="note unreleased"><br>    <h5>Test Title</h5><br>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p><br></div>

<p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p>
<p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p>
<p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
</feed>
